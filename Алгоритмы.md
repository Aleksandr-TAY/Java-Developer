[Вопросы для собеседования](README.md)

# Алгоритмы
+ [ArrayList vs LinkedList](#ArrayList-vs-LinkedList)
+ [Устройство HashMap](#Устройство-HashMap)
+ [Рекурсия](#Рекурсия)
+ [Рекурсия vs Iterator](#Рекурсия-vs-Iterator)
+ [Виды сортировок и их сравнение](#Виды-сортировок-и-их-сравнение)
+ [Виды поиска и их сравнение](#Виды-поиска-и-их-сравнение)
+ [Жадный алгоритм](#Жадный-алгоритм)
+ [Временная сложность алгоритмов](#Временная-сложность-алгоритмов)
+ [Queue, Deque, stack, Heap](#Queue-Deque-Stack-Heap)
+ [Бинарное дерево](#Бинарное-дерево)
+ [Красно-черное дерево](#Красно-черное-дерево)
+ [Пять ограничений на Red Black Tree](#Пять-ограничений-на-Red-Black-Tree)
+ [Меморизация](#Меморизация)

## Big O
Концепция Big O показывает, какое количество шагов (тактов процессора) необходимо сделать, чтобы полностью завершить алгоритм.

Big O показывает верхную границу _зависимости между входными параметрами функции_ и _количеством операций_, которые выполнит процессор. Т.е. описывается только скорость роста функции. Если алгоритм описывается как O(2N), он все равно будет O(n), посколько константы можно отбросить. Не важно, сколько раз будет повторятся алгоритм - бесконечность (n) или две бесконечности (2n) - это все равно будет бесконечность.

Концепция Big O помогает видеть и исправлять неоптимальный код.

```java
   
время
   .          
  / \       /
   |       /
   |      /  O(n)
   |     /
   |    /
   |   /
   |  /
   |-/------------------- O(1)
   |/
   |
   o——————————————————> 
                кол-во бит
```
__O(n)__ - Больше байт - дольше передавать. Зависимость от количества элементов. В функции это кол-во вызовов функции внутри себя
__О(1)__ - Размер файла не важен, скорость постоянна

__Рекурсивная функция:__ функция вызывает сама себя. Чем больше n, тем больше раз функция вызовет сама себя.
```java
int sum(int n) {
    if (n == 1) return 1;
    return n + sum(n - 1);
}
```
__Линейная функция:__ кол-во выполнений функции зависит от n.
```java
int pairSunSequence(int n) {
    int sum = 0:
    for (int i = 0; i < n; i++) {
        sum += pairSum(i, i + 1);
    }
    return sum;
}

int pairSum(int a, int b) {
    return a + b;
}
```
__Отбрасывание неважной сложности:__ если одно значение n значительно (в 2 раза) меньше другого значения n^2, то меньшуу n можно отбросить, т.к. она слабо влияет на рост скорости фукнции.

O(n^2 + n) = O(n^2)

O(n + log n) = O(n), т.к log(n) меньше n

O(5 * 2^n + 10 * n^100) = O(2^n)

O(n^2 + b) = O(n^2 + b), мы не может упростить, пока ничего не знаем о b. Оно может быть <, > или = n

__Сложение и умножение сложностей__: Если функции вызываются последовательно, то сложности складываются (они не зависят друг от друга). Если функции выполняются одна в другой (зависят друг от друга) то сложности умножаются.

__Log n__ - для алгоритма, где на каждой итерации берется половина элементов - сложность будет включать O(log n).

## ArrayList vs LinkedList
    Класс          Индекс     Поиск     Вставка     Удаление
    
    ArrayList       O(1)       O(n)       O(n)         O(n)
    LinkedList      O(n)       O(n)       O(1)         O(1)

__ArrayList__ реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.

__LinkedList__ реализован в виде двусвязного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно. 

Если вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях – ArrayList.

## Устройство HashMap
