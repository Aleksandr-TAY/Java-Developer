[Вопросы для собеседования](README.md)

# JDBC
+ [Что такое JDBC?](#Что-такое-jdbc)
+ [Что такое JPA?](#Что-такое-jpa)
+ [Различия между JPA, JDBC и Hibernate?](#Различия-между-jpa-jdbc-и-hibernate)
+ [В чем заключаются преимущества использования JDBC?](#В-чем-заключаются-преимущества-использования-jdbc)
+ [Что из себя представляет JDBC URL?](#Что-из-себя-представляет-jdbc-url)
+ [Из каких частей стоит JDBC?](#Из-каких-частей-стоит-jdbc)
+ [Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?](#Перечислите-основные-классы-и-интерфейсы-jdbc)
+ [Опишите основные этапы работы с базой данных с использованием JDBC.](#Опишите-основные-этапы-работы-с-базой-данных-при-использовании-jdbc)
+ [Как зарегистрировать драйвер JDBC?](#Как-зарегистрировать-драйвер-jdbc)
+ [Как установить соединение с базой данных?](#Как-установить-соединение-с-базой-данных)
+ [Какие уровни изоляции транзакций поддерживаются в JDBC?](#Какие-уровни-изоляции-транзакций-поддерживаются-в-jdbc)
+ [При помощи чего формируются запросы к базе данных?](#При-помощи-чего-формируются-запросы-к-базе-данных)
+ [Чем отличается Statement от PreparedStatement?](#Чем-отличается-statement-от-preparedstatement)
+ [Как осуществляется запрос к базе данных и обработка результатов?](#Как-осуществляется-запрос-к-базе-данных-и-обработка-результатов)
+ [Как вызвать хранимую процедуру?](#Как-вызвать-хранимую-процедуру)
+ [Как закрыть соединение с базой данных?](#Как-закрыть-соединение-с-базой-данных)
+ [Что такое Entity?](#Что-такое-entity)
+ [Как наследуется Entity?](#Как-наследуется-entity)

## Что такое _ORM_?
__ORM (Object-relational mapping)__ — технология программирования, которая позволяет преобразовывать несовместимые типы моделей в ООП, в частности, между хранилищем данных и объектами программирования. ORM используется для упрощения процесса сохранения объектов в реляционную базу данных и их извлечения, при этом ORM сама заботится о преобразовании данных между двумя несовместимыми состояниями.

[к оглавлению](#jdbc)

## Что такое _JDBC_?
__JDBC, Java DataBase Connectivity (соединение с базами данных на Java)__ — промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета `java.sql`, входящего в состав Java SE.

JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

[к оглавлению](#jdbc)

## Что такое _JPA_?
__JPA (Java Persistence API)__ это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть существует много реализаций данной спецификации от разных компаний.

[к оглавлению](#jdbc)

## Различия _JPA_ _JDBC_ и __Hibernate__?
JDBC является гораздо более низкой (и более старой) спецификацией, чем JPA. JDBC - это API-интерфейс для взаимодействия с базой данных с использованием чистого SQL - отправки запросов и получения результатов. Он не имеет понятия об объектах или иерархиях. При использовании JDBC вам необходимо преобразовать набор результатов в объекты Java. 

А в JPA (который использует JDBC снизу) вы также указываете эти детали метаданных базы данных, но с использованием аннотаций Java. Таким образом, JPA создает запросы на обновление для вас и управляет объектами, которые вы искали или создали / обновили (это также делает больше).

Hibernate одна из самых популярных открытых реализаций последней версии спецификации. То есть JPA только описывает правила и API, а Hibernate реализует эти описания.

[к оглавлению](#jdbc)

## Что такое JPQL и HQL?
+ JPQL — Java Persistence Query Language. Фактически это как SQL, только запросы делаются не к таблицам, а к классам. JPQL основан на HQL.
+ HQL — Hibernate Query Language. Аналог SQL, но работает с сохраняемыми объектами (Persistent Objects) и их полями (аттрибутами класса). Мы также имеем возможность испольщовать обычные SQL – запросы в Hibernate используя Native SQL

## В чем заключаются преимущества использования JDBC?
Преимуществами JDBC считают:

+ Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;
+ Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);
+ Не нужно дополнительно устанавливать клиентскую программу;
+ К любой базе данных можно подсоединиться через легко описываемый URL.

[к оглавлению](#jdbc)

## Что из себя представляет JDBC URL?
__JDBC URL__ состоит из:

+ `<protocol>:` (протокола) - всегда `jdbc:`.
+ `<subprotocol>:` (подпротокола) - это имя драйвера или имя механизма соединения с базой данных. Подпротокол может поддерживаться одним или несколькими драйверами. Лежащий на поверхности пример подпротокола - это "odbc", отведенный для URL, обозначающих имя источника данных ODBC. В случае необходимости использовать сервис имен (т.е. имя базы данных в JDBC URL не будет действительным именем базы данных), то подпротоколом может выступать сервис имен.
+ `<subname>` (подимени) - это идентификатор базы данных. Значение подимени может менятся в зависимости от подпротокола, и может также иметь под-подимя с синтаксисом, определяемым разработчиком драйвера. Назначение подимени - это предоставление всей информации, необходимой для поиска базы данных. Например, если база данных находится в Интернет, то в состав подимени JDBC URL должен быть включен сетевой адрес, подчиняющийся следующим соглашениям: `//<hostname>:<port>/<subsubname`.

Пример JDBC URL для подключения к MySQL базе данных «Test» расположенной по адресу localhost и ожидающей соединений по порту 3306: `jdbc:mysql://localhost:3306/Test`

[к оглавлению](#jdbc)

## Из каких частей стоит JDBC?
JDBC состоит из двух частей:

+ __JDBC API__, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и методы объявлены в двух пакетах - `java.sql` и `javax.sql`;
+ __JDBC-драйвер__, компонент, специфичный для каждой базы данных. 

JDBC превращает вызовы уровня API в «родные» команды того или иного сервера баз данных.

[к оглавлению](#jdbc)

## Перечислите основные классы и интерфейсы JDBC.
+ `java.sql.DriverManager` - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.

+ `javax.sql.DataSource` - решает те же задачи, что и _DriverManager_, но более удобным и универсальным образом. Существуют также `javax.sql.ConnectionPoolDataSource` и `javax.sq1.XADataSource` задача которых - обеспечение поддержки пула соединений.

+ `java.sql.Connection`  - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы `javax.sql.PooledConnection` и `javax.sql.XAConnection`.

+ `java.sql.Statement` , `java.sql.PreparedStatement` и `java.sql.CallableStatement`  - эти интерфейсы позволяют отправить запрос к источнику данных.

+ `java.sql.ResultSet`  - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.

+ `java.sql.ResultSetMetaData`  - позволяет получить информацию о структуре набора данных.

+ `java.sql.DatabaseMetaData` - позволяет получить информацию о структуре источника данных.

[к оглавлению](#jdbc)

## Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?

| JDBC Type | Java Object Type |
|---------------:|---------------------------|
| __CHAR__ | `String` |
| __VARCHAR__ | `String` |
| __LONGVARCHAR__ | `String` |
| __NUMERIC__ | `java.math.BigDecimal` |
| __DECIMAL__ | `java.math.BigDecimal` |
| __BIT__ | `Boolean` |
| __TINYINT__ | `Integer` |
| __SMALLINT__ | `Integer` |
| __INTEGER__ | `Integer` |
| __BIGINT__ | `Long` |
| __REAL__ | `Float` |
| __FLOAT__ | `Double` |
| __DOUBLE__ | `Double` |
| __BINARY__ | `byte[]` |
| __VARBINARY__ | `byte[]` |
| __LONGVARBINARY__ | `byte[]` |
| __DATE__ | `java.sql.Date` |
| __TIME__ | `java.sql.Time` |
| __TIMESTAMP__ | `java.sql.Timestamp` |
| __CLOB__ | `Clob` |
| __BLOB__ | `Blob` |
| __ARRAY__ | `Array` |
| __STRUCT__ | `Struct`|
| __REF__ | `Ref` |
| __DISTINCT__ | сопоставление базового типа |
| __JAVA_OBJECT__ | базовый класс Java |

[к оглавлению](#jdbc)

## Опишите основные этапы работы с базой данных при использовании JDBC.
+ Регистрация драйверов;
+ Установление соединения с базой данных;
+ Создание запроса(ов) к базе данных;
+ Выполнение запроса(ов) к базе данных;
+ Обработка результата(ов);
+ Закрытие соединения с базой данных.

[к оглавлению](#jdbc)

## Как зарегистрировать драйвер JDBC?
Регистрацию драйвера можно осуществить несколькими способами:

+ `java.sql.DriverManager.registerDriver(%объект класса драйвера%)`.  

+ `Class.forName(«полное имя класса драйвера»).newInstance()`.

+ `Class.forName(«полное имя класса драйвера»)`;

[к оглавлению](#jdbc)

## Как установить соединение с базой данных?
Для установки соединения с базой данных используется статический вызов `java.sql.DriverManager.getConnection(...)` .


В качестве параметра может передаваться:

+ URL базы данных
```java
static Connection getConnection(String url)
```

+ URL базы данных и набор свойств для инициализации
```java
static Connection getConnection(String url, Properties info)
```

+ URL базы данных, имя пользователя и пароль
```java
static Connection getConnection(String url, String user, String password)
```
 
В результате вызова будет установлено соединение с базой данных и создан объект класса `java.sql.Connection` - своеобразная «сессия», внутри контекста которой и будет происходить дальнейшая работа с базой данных.

[к оглавлению](#jdbc)

## Какие уровни изоляции транзакций поддерживаются в JDBC?
__Уровень изолированности транзакций__ — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:

+ _«грязное» чтение (dirty read)_ — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);

+ _неповторяющееся чтение (non-repeatable read)_ — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;

+ _фантомное чтение (phantom reads)_ — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

Уровни изоляции транзакций определены в виде констант интерфейса `java.sql.Connection`:

+ `TRANSACTION_NONE` – драйвер не поддерживает транзакции;

+ `TRANSACTION_READ_UNCOMMITTED` – позволяет транзакциям видеть несохраненные изменения данных: разрешает грязное, непроверяющееся и фантомное чтения;

+ `TRANSACTION_READ_COMMITTED` – любое изменение, сделанное в транзакции, не видно вне неё, пока она не сохранена: предотвращает грязное чтение, но разрешает непроверяющееся и фантомное;

+ `TRANSACTION_REPEATABLE_READ` – запрещает грязное и непроверяющееся, фантомное чтение разрешено;

+ `TRANSACTION_SERIALIZABLE` – грязное, непроверяющееся и фантомное чтения запрещены.

> __NB!__ Сервер базы данных может не поддерживать все уровни изоляции. Интерфейс `java.sql.DatabaseMetaData` предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.

Уровень изоляции транзакции используемый СУБД можно задать с помощью метода `setTransactionIsolation()` объекта `java.sql.Connection`. Получить информацию о применяемом уровне изоляции поможет метод `getTransactionIsolation()`.

[к оглавлению](#jdbc)

## При помощи чего формируются запросы к базе данных?

Для выполнения запросов к базе данных в Java используются три интерфейса:

+ `java.sql.Statement` - для операторов SQL без параметров;
+ `java.sql.PreparedStatement` - для операторов SQL с параметрами и часто выполняемых операторов;
+ `java.sql.CallableStatement` -  для исполнения хранимых в базе процедур.

Объекты-носители интерфейсов создаются при помощи методов объекта `java.sql.Connection`:

+ `java.sql.createStatement()` возвращает объект _Statement_;
+ `java.sql.prepareStatement()` возвращает объект _PreparedStatement_;
+ `java.sql.prepareCall()` возвращает объект _CallableStatement_;

[к оглавлению](#jdbc)

## Чем отличается Statement от PreparedStatement?
+ __Statement__: используется для простых случаев запроса без параметров.
+ __PreparedStatement__: предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.

Перед выполнением СУБД разбирает каждый запрос, оптимизирует его и создает «план» (query plan) его выполнения. Если один и тот же запрос выполняется несколько раз, то СУБД в состоянии кэшировать план его выполнения и не производить этапов разборки и оптимизации повторно. Благодаря этому запрос выполняется быстрее.

Суммируя: _PreparedStatement_ выгодно отличается от _Statement_ тем, что при повторном использовании с одним или несколькими наборами параметров позволяет получить преимущества заранее прекомпилированного и кэшированного запроса, помогая при этом избежать SQL Injection.

[к оглавлению](#jdbc)

## Как осуществляется запрос к базе данных и обработка результатов?
Выполнение запросов осуществляется при помощи вызова методов объекта, реализующего интерфейс `java.sql.Statement`:

+ __`executeQuery()`__ -  для запросов, результатом которых является один набор значений, например запросов `SELECT`. Результатом выполнения является объект класса `java.sql.ResultSet`;
 
+ __`executeUpdate()`__ - для выполнения операторов `INSERT`, `UPDATE` или `DELETE`, а также для операторов _DDL (Data Definition Language)_. Метод возвращает целое число, показывающее, сколько записей было модифицировано;

+ __`execute()`__ – исполняет SQL-команды, которые могут возвращать различные результаты. Например, может использоваться для операции `CREATE TABLE`. Возвращает `true`, если первый результат содержит _ResultSet_ и `false`, если первый результат - это количество модифицированных записей или результат отсутствует. Чтобы получить первый результат необходимо вызвать метод `getResultSet()` или `getUpdateCount()`. Остальные результаты доступны через вызов `getMoreResults()`, который при необходимости может быть произведён многократно.

Объект с интерфейсом `java.sql.ResultSet` хранит в себе результат запроса к базе данных - некий набор данных, внутри которого есть курсор, указывающий на один из элементов набора данных - текущую запись.

Используя курсор можно перемещаться по набору данных при помощи метода `next()`.

> __NB!__ Сразу после получения набора данных его курсор находится перед первой записью и чтобы сделать её текущей необходимо вызвать метод `next()`.

Содержание полей текущей записи доступно через вызовы методов `getInt()`, `getFloat()`, `getString()`, `getDate()` и им подобных.

[к оглавлению](#jdbc)

## Как вызвать хранимую процедуру?
__Хранимые процедуры__ – это именованный набор операторов SQL хранящийся на сервере. Такую процедуру можно вызвать из Java-класса с помощью вызова методов объекта реализующего интерфейс `java.sql.Statement`.

Выбор объекта зависит от характеристик хранимой процедуры:

+ без параметров → `Statement`
+ с входными параметрами → `PreparedStatement`
+ с входными и выходными параметрами → `CallableStatement`

> Если неизвестно, как была определена хранимая процедура, для получения информации о хранимой процедуре (например, имен и типов параметров) можно использовать методы `java.sql.DatabaseMetaData` позволяющие получить информацию о структуре источника данных.

Пример вызова хранимой процедуры с входными и выходными параметрами:

```java
public vois runStoredProcedure(final Connection connection) throws Exception {
    // описываем хранимую процедуру
    String procedure = "{ call procedureExample(?, ?, ?) }";
    
    // подготавливаем запрос
    CallableStatement cs = connection.prepareCall(procedure);
    
    // устанавливаем входные параметры
    cs.setString(1, "abcd");
    cs.setBoolean(2, true);
    cs.setInt(3, 10);
    
    // описываем выходные параметры
    cs.registerOutParameter(1, java.sql.Types.VARCHAR);
    cs.registerOutParameter(2, java.sql.Types.INTEGER);
    
    // запускаем выполнение хранимой процедуры
    cs.execute();
    
    // получаем результаты
    String parameter1 = cs.getString(1);
    int parameter2 = cs.getInt(2);
    
    // заканчиваем работу с запросом
    cs.close();
}
```

[к оглавлению](#jdbc)

## Как закрыть соединение с базой данных?
Соединение с базой данной закрывается вызовом метода `close()` у соответствующего объекта `java.sql.Connection` или посредством использования механизма try-with-resources при создании такого объекта, появившегося в Java 7.

> __NB!__ Предварительно необходимо закрыть все запросы созданные этим соединением.

[к оглавлению](#jdbc)

## Что такое Entity?
Entity это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это entity класс, который так же может использовать дополнительные классы, который могут использоваться как вспомогательные классы или для сохранения состояния еntity.

JPA указывает что она может работать как с свойствами классов (property), оформленные в стиле JavaBeans, либо с полями (field), то есть переменными класса (instance variables). Соответственно, при этом тип доступа будет либо property access или field access. Оба типа элементов Entity класса называются _атрибутами Entity класса_.

Допустимые типы атрибутов у Entity классов:
+ примитивные типы и их обертки Java,
+ строки,
+ любые сериализуемые типы Java (реализующие Serializable интерфейс),
+ enums;
+ entity types;
+ embeddable классы
+ и коллекции типов 1-6

Требования JPA к Entity классам:
1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами),
3) Entity класс должен быть классом верхнего уровня (top-level class),
4) Entity класс не может быть enum или интерфейсом,
5) Entity класс не может быть финальным классом (final class),
6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
9) Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,

[к оглавлению](#jdbc)

## Как наследуется Entity?
+ Может наследоваться и от других Entity классов, и от не Entity классов. 
+ Не Entity классы так же могут наследоваться от Entity. 
+ Может быть абстрактным, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

[к оглавлению](#jdbc)
## Что такое POJO-класс?
Plain Old Java Object - простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

[к оглавлению](#jdbc)

## Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса (составной или простой), чтобы полученный первичный ключ мог использоваться для любой базы данных? А в случае автогенерируемого первичного ключа (generated primary keys)?
Допустимые типы атрибутов, входящих в первичный ключ:
1. примитивные типы и их обертки Java,
2. строки,
3. BigDecimal и BigInteger,
4. java.util.Date и java.sql.Date

В случае автогенерируемого первичного ключа (generated primary keys) допустимы только числовые типы.<br>
В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е. становится не переносимым (not portable).

[к оглавлению](#jdbc)

## Что такое встраиваемый (Embeddable) класс?
Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity, можно считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.

[к оглавлению](#jdbc)

## Может ли встраиваемый (Embeddable) класс содержать другой встраиваемый (Embeddable) класс?
Да, может.

[к оглавлению](#jdbc)

## Может ли встраиваемый (Embeddable) класс содержать связи (relationship) с другими Entity или коллекциями Entity? Если может, то существуют ли какие-то ограничение на такие связи (relationship)?
Может, но только в случае если такой класс не используется как первичный ключ или ключ map’ы.

[к оглавлению](#jdbc)

## Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity (см. вопрос 10),
2. Embeddable класс должен быть отмечен аннотацией Embeddable или описан в XML файле конфигурации JPA.

[к оглавлению](#jdbc)
## Основные классы и интерфейсы JPA
__EntityManagerFactory__ – фабричный класс EntityManager. Он создает и управляет несколькими экземплярами EntityManager. Создание EntityManagerFactory  довольно дорогая операция, поэтому обычно её создают один раз и на всё приложение.

Методы:
+ createEntityManager()
+ createEntityManager(Map map) - Create a new application-managed EntityManager with the specified Map of properties.
+ close() - Close the factory, releasing any resources that it holds.
+ getCache() - Access the cache that is associated with the entity manager factory (the "second level cache").
+ getCriteriaBuilder() - Return an instance of CriteriaBuilder for the creation of CriteriaQuery objects.
+ getMetamodel() - Return an instance of Metamodel interface for access to the metamodel of the persistence unit.
+ getPersistenceUnitUtil() - Return interface providing access to utility methods for the persistence unit.
+ getProperties() - Get the properties and associated values that are in effect for the entity manager factory.
+ isOpen() - Indicates whether the factory is open.

__EntityManager__ – интерфейс, вызывая методы которого можно управлять сущностями. В отличие от фабрики, достаточно легковесен и поэтому зачастую создаётся по месту использования и в больших количествах. Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.

__Методы операций над Entity:__
+ persist (добавление Entity под управление JPA)
+ merge (обновление)
+ remove (удаления)
+ refresh (обновление данных)
+ detach (удаление из управление JPA)
+ lock (блокирование Enity от изменений в других thread).
__Методы получение данных:__
+ find (поиск и получение Entity)
+ createQuery, createNamedQuery, createNativeQuery
+ contains
+ createNamedStoredProcedureQuery, createStoredProcedureQuery
__Получение других сущностей JPA:__ 
+ getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
__Работа с EntityGraph:__
+ createEntityGraph, getEntityGraph
__Общие операции над EntityManager или всеми Entities:__ 
+ close, isOpen, getProperties, setProperty, clear.

__Entity__ – это постоянные объекты, хранящиеся в виде записей в базе данных.

__EntityTransaction__ – интерфейс для работы с транзакциями. Он имеет непосредственное отношение к EntityManager. Для каждого EntityManager операции поддерживаются классом EntityTransaction.

Методы: 
+ begin() - Start a resource transaction.
+ commit() - Commit the current resource transaction, writing any unflushed changes to the database.
+ getRollbackOnly() - Determine whether the current resource transaction has been marked for rollback.
+ isActive() - Indicate whether a resource transaction is in progress.
+ rollback() - Roll back the current resource transaction.
+ setRollbackOnly() - Mark the current resource transaction so that the only possible outcome of the transaction is for the transaction to be rolled back.

__Persistence__ – Этот класс содержит статические методы для получения экземпляра EntityManagerFactory.

__Query__ – Этот интерфейс реализуется каждым поставщиком JPA для получения реляционных объектов, соответствующих критериям.

[к оглавлению](#jdbc)
## Что такое Метамодель?
Для получения метаданные JPA (сведения о Entity типах, Embeddable и Managed классах и т.п.) используется интерфейс Metamodel. Объект этого интерфейса можно получить методом getMetamodel у EntityManagerFactory или EntityManager.

[к оглавлению](#jdbc)
## Основные классы и интерфейсы Hibernate?
__SessionFactory__ – используется для получения объектов Session, которые используются для операций с базами данных. SessionFactory отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных. Неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных. Необходимо инициализировать SessionFactory всего один раз.

__Session__ – однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных. Он оборачивает JDBC java.sql.Connection и работает как фабрика для org.hibernate.Transaction. Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования. Экземпляр Session является интерфейсом между кодом в java приложении и hibernate framework и предоставляет методы для операций CRUD. 

__Transaction__ – однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать несколько org.hibernate.Transaction в определенных случаях.

__Configuration__ - этот объект используется для создания объекта SessionFactory и конфигурирует сам Hibernate

[к оглавлению](#jdbc)

## Способы сконфигурировать Hibernate?
+ используя аннотации
+ hibernate.cfg.xml
+ hibernate.properties
+ persistence.xml

## SessionFactory vs EntityManagerFactory и Session vs EntityManager?
Hibernate появился раньше JPA. К этому времени у HIBERNATE был большой наработанный функционал, а в для первой версии JPA удалось согласовать только часть этого объема функционала. Поэтому, разработчики HIBERNATE сознательно пошли на то, чтобы в HIBERNATE имелось два пути работы - старый путь - нативный HIBERNATE (через интерфейс Session) и новый путь JPA (через интерфейс EntityManager). 

Интерфейсы разные, методы как правило имеют одинаковые названия. Различия есть и в других элементах. При этом, функциональность нативного HIBERNATE значительно больше, чем у JPA. И вообще, реализация EntityManager является оберткой (wrap) реализации Session. Класс SessionImpl реализует интерфейс Session, а Session расширяет интерфейс EntityManager. 

Если Вы выбираете путь JPA, то всегда имеете возможность быстро перейти, на другие реализации JPA- EclipseLink, OpenJPA, DataNucleus (и узнаете насколько они совместимы).

[к оглавлению](#jdbc)

## Жизненный цикл Entity?
У Entity объекта существует четыре статуса жизненного цикла: 
+ new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных,
+ managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи,
+ detached — объект был создан, но не управляется (или больше не управляется) JPA,
+ removed — объект создан, управляется JPA, но будет удален после commit'a транзакции

## Влияние операций EntityManager на Entity объекты различный жизненных циклов?
__Persist__ <br>
1) Если статус Entity new, то он меняется на managed и объект будет сохранен в базу при commit'е транзакции или в результате flush операций,
2) Если статус уже managed, операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений,
3) Если статус removed, то он меняется на managed,
4) Если статус detached, будет выкинут exception сразу или на этапе commit'а транзакции,

__Remove__<br>
1) Если статус Entity new, операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed,
2) Если статус managed, то статус меняется на removed и запись объект в базе данных будет удалена при commit'е транзакции (так же произойдут операции remove для всех каскадно зависимых объектов),
3) Если статус removed, то операция игнорируется,
4) Если статус detached, будет выкинут exception сразу или на этапе commit'а транзакции,

__Merge__<br>
1) Если статус detached, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные,
1) Если статус Entity new, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта,
2) Если статус managed, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed,
3) Если статус removed, будет выкинут exception сразу или на этапе commit'а транзакции,

__Refresh__<br>
1) Если статус Entity managed, то в результате операции будут востановлены все изменения из базы данных данного Entity, так же произойдет refresh всех каскадно зависимых объектов,
2) Если статус new, removed или detached, будет выкинут exception,

__Detach__<br>
1) Если статус Entity managed или removed, то в результате операции статус Entity (и всех каскадно-зависимых объектов) станет detached.
2) Если статус new или detached, то операция игнорируется,

## Аннотации JPA
@Access — аннотация используется для указания типа доступа связанного класса сущности, сопоставленного супер класса или встраиваемого класса или атрибута сущности.

@AssociacionOverride — аннотация используется для переопределения реляционных отношений таких как один к одному, многие к одному, один ко многим, многие ко многим (@OneToOne, @ManyToOne, @OneToMany, @ManyToMany) в классах унаследованных от встраиваемых (embeddable) или сопоставляемых супер классов (mapped superclass).

@AssociacionOverrides — аннотация используется для группировки нескольких аннотаций @AssociacionOverride.

@AttibuteOverride — аннотация используется для переопределения сопоставляемых атрибутов Entity классов унаследованных от встраиваемых (embeddable) или сопоставляемых супер классов (mapped superclass). Подробнее...

@AttibuteOverrides — аннотация используется для группировки нескольких аннотаций @AttributeOverride.

@Basic — аннотация используется для сопоставления базового типа атрибута столбцу таблицы базы данных.

@Cacheable — аннотация используется для определения хранения объекта в кэше второго уровня в зависимости от установленного свойства [shared-cache-mode] в файле persistence.xml. При значении [shared-cache-mode] - ENABLE SELECTIVE - в кэше второго уровня будут храниться только объекты помеченные аннотацией @Cacheable. При значении [shared-cache-mode] - DISABLE SELECTIVE - в кэше второго уровня будут храниться только объекты не помеченные аннотацией @Cacheable.

@CollectionTable — аннотация используется для указания таблицы базы данных, в которой хранятся значения базовой или встраиваемой коллекции типов.

@Column — аннотация используется для указания соответствия между атрибутом базовой сущности Entity класса и столбцом таблицы базы данных. Подробнее...

@ColumnResult — аннотация @ColumnResult используется в сочетании с аннотациями @SqlResultSetMapping или @ConstructorResult для отображения столбца SQL для заданного запроса SELECT.

@ConstructorResult — аннотация используется в сочетании с аннотациями @SqlResultSetMapping для сопоставления столбцов заданного запроса SELECT определенному конструктору объекта.

@Convert — аннотация используется для определения реализации AttributeConverter, используемой для преобразования текущего аннотированного базового атрибута. Если AttributeConverter использует autoApply, все атрибуты сущностей с одним и тем же целевым типом будут автоматически преобразованы.

@Converter — аннотирование используется, чтобы указать, что текущая реализация AttributeConverter аннотации может использоваться в качестве конвертора основных атрибутов JPA. Если атрибуту autoApply присвоено значение true, поставщик JPA автоматически преобразует все базовые атрибуты с тем же типом Java, как определено текущим преобразователем.

@Converts — аннотация используется для группирования нескольких аннотаций @Convert.

@DiscriminatorColumn — аннотация используется для указания имени столбца дискриминатора и типа дискриминатора для стратегий наследования (Inheritance) SINGLE_TABLE и JOINED.

@DisccriminatorValue — аннотация используется для определения того, какое значение столбца дискриминатора используется для отображения текущего аннотированного объекта для стратегий наследования (Inheritance) SINGLE_TABLE и JOINED.

@ElementCollection — аннотация используется для указания коллекции базового или встраиваемого типа.

@Embeddable — аннотация используется для указания встраиваемых типов. Как и базовые типы, встраиваемые типы не имеют никакой идентичности, управляемой их собственностью.

@Embedded — аннотация используется, чтобы указать, что данный атрибут сущности представляет встраиваемый тип.

@EmbeddedId — аннотация используется, чтобы указать, что идентификатор объекта является встраиваемым типом.

@Entity — аннотация используется, чтобы указать, что текущий класс представляет тип сущности - Entity класса. В отличие от базовых и встраиваемых типов, типы сущностей имеют идентичность, а их состояние управляется базовым контекстом Persistence. Подробнее...

@EntityListeners — аннотация используется для указания массива классов слушателя обратного вызова, которые используются текущей аннотированной сущностью.

@EntityResult — аннотация используется с аннотацией @SqlResultSetMapping для сопоставления выбранных столбцов сущности.

@Enumerated — аннотация используется, чтобы указать, что атрибут entity представляет перечислимый тип.

@ExcludeDefaultListeners — аннотация используется, чтобы указать, что текущая аннотированная сущность пропускает вызов любого слушателя по умолчанию.

@ExcludeSuperlassListeners — аннотация используется, чтобы указать, что текущая аннотированная сущность пропускает вызов слушателей, объявленных его суперклассом (классом предком).

@FieldResult — аннотация используется с аннотацией @EntityResult для сопоставления выбранных столбцов полям определенного объекта.

@ForeignKey  — аннотация используется для указания связанного внешнего ключа сопоставления @JoinColumn. Аннотация @ForeignKey используется только в том случае, если включен инструмент автоматического создания и корректировки схемы базы данных, и в этом случае аннотация позволяет настроить определение базового внешнего ключа.

@GeneratedValue — аннотация указывает метод генерации значения идентификатора (автоматически генерируется с использованием столбца идентификации, последовательности базы данных или генератора таблиц). Hibernate поддерживает сопоставление @GeneratedValue даже для идентификаторов UUID.

@Id — аннотация указывает идентификатор объекта. Объект должен всегда иметь атрибут идентификатора, который используется при загрузке объекта в данном контексте сохранения.

@IdClass — аннотация используется, если текущий объект определяет составной идентификатор. Отдельный класс инкапсулирует все атрибуты идентификатора, которые зеркалируются текущим сопоставлением объектов.

@Index — аннотация используется для создания индекса базы данных если включен инструмент автоматического создания и корректировки схемы базы данных.

@Inheritance — аннотирование используется для указания стратегии наследования для данной иерархии классов сущностей.

@JoinColumn — аннотация используется для указания столбца FOREIGN KEY, используемого при присоединении к ассоциации объекта или встраиваемой коллекции.

@JoinColumns — аннотация используется для группирования нескольких аннотаций @JoinColumn, которые используются при сопоставлении объектов или встраиваемой коллекции с использованием составного идентификатора.

@JoinTable — аннотация используется для указания таблицы связей между двумя другими таблицами базы данных.

@Lob — аннотация используется, чтобы указать, что текущий аннотированный атрибут объекта представляет большой тип объекта.

@ManyToMany — аннотация используется для указания отношения объектов базы данных «многие-ко-многим».

@ManyToOne — аннотация используется для указания отношения «многие-к-одному» для объектов базы данных.

@MapKey — аннотация используется для указания ключа ассоциации java.util.Map, для которой ключ является либо первичным ключом, либо атрибутом объекта, который представляет значение Map.

@MapKeyClass — аннотация используется для указания ключа ассоциаций типа java.util.Map.

@MapKeyColumn — аннотация используется для указания столбца базы данных, в котором хранится ключ ассоциации java.util.Map, для которой ключ карты является базовым типом.

@MapKeyEnumerated — аннотация используется, чтобы указать, что ключ из ассоциации java.util.Map является Java Enum.

@MapKeyJoinColumn — аннотация используется, чтобы указать, что ключ ассоциации java.util.Map является ассоциацией сущностей. Ключевой столбец карты - это FOREIGN KEY в таблице связей, который также присоединяет таблицу владельца карты к таблице, в которой находится значение Map.

@MapKeyJoinColumns — аннотация используется для группирования нескольких сопоставлений @MapKeyJoinColumn, когда ключ ассоциации java.util.Map использует составной идентификатор.

@MapKeyTemporal — аннотация используется, чтобы указать, что ключом ассоциации java.util.Map является @TemporalType (например, DATE, TIME, TIMESTAMP).

@MappedSuperlass — аннотация используется, чтобы указать, что текущие атрибуты аннотированного типа наследуются любой Entity сущностью класса-наследника. Подробнее...

@MapsId — аннотация используется, чтобы указать, что идентификатор объекта сопоставляется текущей аннотированной ассоциацией @ManyToOne или @OneToOne.

@NamedAttributeNode — аннотация используется для указания каждого индивидуального узла атрибута, который необходимо извлечь с помощью диаграммы сущностей.

@NamedEntityGraph — аннотация используется для указания графа сущностей, который может использоваться запросом сущности, чтобы переопределить план выборки по умолчанию.

@NamedEntityGraphs — аннотация используется для группировки нескольких аннотаций @NamedEntityGraph.

@NamedNativeQueries — аннотация используется для объединения нескольких аннотаций @NamedNativeQuery.

@NamedNativeQuery — аннотация используется для указания нативного SQL-запроса, который впоследствии можно найти по его имени.

@NamedQueries — аннотация используется для группирования нескольких аннотаций @NamedQuery.

@NamedQuery — аннотация используется для указания JPQL-запроса, который впоследствии можно найти по его имени.

@NamedStoredProcedureQueries — аннотация используется для группирования нескольких аннотаций @NamedStoredProcedureQuery.

@NamedStoredProcedureQuery — аннотация используется для указания хранимой процедуры базы данных, которую впоследствии можно найти по его имени.

@NamedSubgraph — аннотация используемая для указания субграфа в графе сущностей.

@OneToMany — аннотация используется для указания отношения объектов базы данных «один ко многим».

@OneToOne — аннотация используется для указания отношения «один к одному» объектов базы данных. Подробнее...

@OrderBy — аннотирование используется для указания атрибутов сущности, используемых для сортировки при получении текущей аннотированной коллекции.

@OrderColumn — аннотирование используется, чтобы указать, что текущий сборник аннотаций должен быть материализован в базе данных.

@PersistenceContext — аннотация используется для указания EntityManager, который необходимо ввести как зависимость.

@PersistenceContexts — аннотация используется для группирования нескольких @PersistenceContext аннотаций.

@PersonistenceProperty — аннотация используется аннотацией @PersistenceContext для объявления свойств провайдера JPA, которые передаются в базовый контейнер при создании экземпляра EntityManager.

@PersonistenceUnit — аннотация используется для указания EntityManagerFactory, которая должна быть введена как зависимость.

@PersonistenceUnits — аннотация используется для группирования нескольких аннотаций @PersistenceUnit.

@PostLoad — аннотация используется для указания метода обратного вызова, который срабатывает после загрузки объекта.

@PostPersist — аннотация используется для указания метода обратного вызова, который срабатывает после сохранения объекта.

@PostRemove — аннотация используется для указания метода обратного вызова, который срабатывает после удаления объекта.

@PostUpdate — аннотация используется для указания метода обратного вызова, который срабатывает после обновления объекта.

@PrePersist — аннотация используется для указания метода обратного вызова, который срабатывает до того, как объект будет сохранен.

@PreRemove — аннотация используется для указания метода обратного вызова, который срабатывает до удаления объекта.

@PreUpdate — аннотация используется для указания метода обратного вызова, который срабатывает до обновления объекта.

@PrimaryKeyJoinColumn — аннотация используется, чтобы указать, что столбец первичного ключа текущего аннотированного объекта также является внешним ключом к некоторому другому объекту (например, таблице базового класса в стратегии наследования JOINED, первичной таблице во вторичном сопоставлении таблиц или родительская таблица в отношении @OneToOne).

@PrimaryKeyJoinColumns — аннотация используется для группирования нескольких аннотаций @PrimaryKeyJoinColumn.

@QueryHint — аннотация используется для указания подсказки поставщика JPA, используемой аннотацией @NamedQuery или аннотацией 
@NamedNativeQuery.

@SecondaryTable — аннотация используется для указания вторичной таблицы для текущего аннотированного объекта Entity класса.

@SecondaryTables — аннотация используется для группирования нескольких аннотаций @SecondaryTable.

@SequenceGenerator — аннотация используется для указания последовательности базы данных, используемой генератором идентификатора текущего аннотированного объекта.

@SqlResultSetMapping — аннотация используется для указания отображения ResultSet собственного SQL-запроса или хранимой процедуры.

@SqlResultSetMappings — аннотация является аннотацией нескольких групп @SqlResultSetMapping.

@StoredProcedureParameter — аннотация используется для указания параметра @NamedStoredProcedureQuery.

@Table — аннотация используется для указания первичной таблицы текущего аннотированного объекта Entity класса. Подробнее...

@TableGenerator — аннотация используется для указания таблицы базы данных, используемой генератором идентификаторов текущего 
аннотированного объекта Entity класса.

@Temporal — аннотация используется для указания TemporalType текущего аннотированного атрибута объекта java.util.Date или java.util.Calendar.

@Transient — аннотация используется для указания того, что данный атрибут сущности не должен сохраняться.

@UniqueConstraint — аннотация используется для указания уникального ограничения, которое должно быть включено генератором автоматической схемы для первичной или вторичной таблицы, связанной с текущим аннотированным объектом.

@Version — аннотация используется для указания атрибута версии сущности Entity класса, используемого для оптимистической блокировки. 

## Аннотации Hibernate
Hibernate значительно расширяет стандартный набор аннотаций определенных спецификацией Java Persistence API (JPA). Использование предложенного набора аннотаций возможно только с Hibernate, перенос программного кода под другую реализацию JPA спецификации становиться невозможным.

@Any — аннотация используется для определения связи any-to-one, которая может указывать на один из нескольких типов сущностей.

@AnyMetaDef — аннотация используется для предоставления метаданных о сопоставлении @Any или @ManyToAny.

@AnyMetaDefs — аннотация используется для группирования нескольких аннотаций @AnyMetaDef.

@AttributeAccessor — аннотация используется для указания настраиваемой PropertyAccessStrategy. Должно использоваться только для присвоения персонализированной PropertyAccessStrategy. Для типа доступа к свойству / полю должна быть предпочтительной аннотация JPA 
@Access. Однако, если эта аннотация используется с любым значением = "свойство" или значением = "поле", она будет действовать так же, как соответствующее использование комментария JPA @Access.

@BatchSize — аннотация используется, чтобы указать размер для пакетной загрузки записей ленивой коллекции.

@Cache — аннотация используется для указания CacheConcurrencyStrategy корневого объекта или коллекции.

@Cascade — аннотация используется для применения определенных стратегий Haskernate CascadeType (например, CascadeType.LOCK, CascadeType.SAVE_UPDATE, CascadeType.REPLICATE) в данной ассоциации. Для каскадирования JPA предпочтительнее использовать javax.persistence.CascadeType. При объединении стратегий JPA и Hibernate CascadeType Hibernate объединит оба набора каскадов.

@Check — аннотация используются для указания произвольного ограничения SQL CHECK, которое может быть определено на уровне класса.

@CollectionId — аннотация используется для указания столбца идентификатора для коллекции идентификаторов.

@CollectionType — аннотация используется для указания пользовательского типа коллекции. Коллекция также может аннотироваться @Type, который определяет тип Hibernate для элементов коллекции.

@ColumnDefault — аннотация используется для указания значения DEFAULT DDL, применяемого при использовании генератора автоматической схемы. Такое же поведение может быть достигнуто с помощью атрибута определения комментария JPA @Column.

@Columns —аннотация используются для группировки нескольких комментариев JPA @Column.

@ColumnTransformer — аннотация используется для настройки способа чтения или чтения заданного значения столбца в базе данных.

@ColumnTransformers — аннотация используются для группирования нескольких аннотаций @ColumnTransformer.

@CreationTimestamp — аннотация используется, чтобы указать, что текущий аннотированный временный тип должен быть инициализирован текущим значением временной отметки JVM.

@DiscriminatorFormula — аннотация используется для указания Hibernate @Formula для разрешения значения дискриминатора наследования.

@DisccriminatorOptions — аннотация используется для обеспечения силы и вставки свойств дискриминатора.

@DynamicInsert — аннотация используется, чтобы указать, что оператор SQL INSERT должен быть сгенерирован всякий раз, когда сущность должна быть сохранена. По умолчанию Hibernate использует кэшированный оператор INSERT, который устанавливает все столбцы таблицы. Когда объект аннотируется аннотацией @DynamicInsert, PreparedStatement будет включать только ненулевые столбцы.

@DynamicUpdate — аннотация используется для указания того, что SQL-запрос UPDATE должен генерироваться всякий раз, когда объект модифицируется. По умолчанию Hibernate использует кэшированный оператор UPDATE, который устанавливает все столбцы таблицы. Когда объект аннотируется аннотацией @DynamicUpdate, PreparedStatement будет включать только столбцы, значения которых были изменены.

@Fetch — аннотация используется для указания специфического для Hibernate режима FetchMode (например, JOIN, SELECT, SUBSELECT), используемого для текущей аннотированной связи

@FetchProfile — аннотация используется для указания настраиваемого профиля выборки, аналогичного графику объекта JPA.

@FetchProfile.FetchOverride — аннотация используется в сочетании с аннотацией @FetchProfile и используется для переопределения стратегии выборки конкретной ассоциации объекта.

@FetchProfiles — аннотация используется для группирования нескольких аннотаций @FetchProfile.

@Filter — аннотация используется для добавления фильтров к объекту или целевому объекту коллекции.

@FilterDefs — аннотация используется для определения определения @Filter (имя, условие по умолчанию и типы параметров, если они есть).

@FilterJoinTable — аннотация используется для добавления возможностей @Filter в коллекцию таблиц соединений.

@FilterJoinTables — аннотация используется для группировки нескольких аннотаций @FilterJoinTable.

@Filters — аннотация используется для группировки нескольких аннотаций @Filter.

@Formula — аннотация используется для указания фрагмента SQL, который выполняется, чтобы заполнить заданный атрибут объекта.

@Generated — аннотация используется, чтобы указать, что текущий аннотированный атрибут объекта генерируется базой данных.

@GeneratorType — аннотация используется для предоставления ValueGenerator и GenerationTime для текущего сгенерированного атрибута.

@GenericGenerator — аннотация можно использовать для настройки любого генератора идентификаторов Hibernate.

@GenericGenerators — аннотация используется для группирования нескольких аннотаций @GenericGenerator.

@Immutable — аннотация используется, чтобы указать, что аннотированный объект, атрибут или коллекция является неизменяемым.

@JoinColumnOrFormula — аннотация используется для указания того, что ассоциация сущностей разрешена либо через соединение FOREIGN KEY (например, @JoinColumn), либо с использованием результата данной формулы SQL (например, @JoinFormula).

@JoinColumnsOrFormulas — аннотация используется для группирования нескольких аннотаций @JoinColumnOrFormula.

@JoinFormula — аннотация используется в качестве замены для @JoinColumn, если в ассоциации нет выделенного столбца FOREIGN KEY.

@LazyCollection — аннотация используется для указания поведения отложенной загрузки для данной коллекции. Возможные значения перечисляются перечислением LazyCollectionOption: TRUE - загружайте его, когда запрашивается состояние. FALSE - с готовностью загрузите его. EXTRA - используйте дополнительные запросы при полной загрузке коллекции. Значения TRUE и FALSE устарели, поскольку вы должны использовать атрибут JPA FetchType коллекции @ElementCollection, @OneToMany или @ManyToMany.

@LazyGroup — аннотация используется для указания того, что атрибут entity должен быть выбран вместе со всеми другими атрибутами, принадлежащими к той же группе. Чтобы лениво загружать атрибуты объектов, требуется улучшение байт-кода. По умолчанию все атрибуты, не относящиеся к коллекции, загружаются в одну группу с именем «DEFAULT». Эта аннотация позволяет определять различные группы атрибутов, которые должны быть инициализированы вместе при доступе к одному атрибуту в группе.

@LazyToOne — аннотация используется для указания параметров отложенной загрузки, представленных LazyToOneOption, доступных для ассоциации @OneToOne или @ManyToOne. LazyToOneOption определяет следующие альтернативы: 
FALSE - срочно загрузите ассоциацию. Этот параметр не нужен, поскольку JPA FetchType.EAGER предлагает такое же поведение. 
NO_PROXY - эта опция будет лениво получать ассоциацию, возвращая реальный объект сущности. 
PROXY - эта опция будет лениво извлекать связь при возврате прокси вместо этого.

@ListIndexBase — аннотация используется для указания начального значения для индекса списка, который хранится в базе данных. По умолчанию индексы списка сохраняются начиная с нуля. Обычно используется вместе с @OrderColumn.

@Loader — аннотация используется для переопределения запроса SELECT по умолчанию, используемого для загрузки загрузки объекта.

@ManyToAny — аннотация используется для указания связи «многие-к-одному» при динамическом разрешении целевого типа.

@MapKeyType — аннотация используется для указания типа ключа Map.

@MetaValue — аннотация используется аннотацией @AnyMetaDef для указания связи между заданным значением дискриминатора и типом объекта.

@NamedNativeQueries — аннотация используется для объединения нескольких аннотаций @NamedNativeQuery.

@NamedNativeQuery — аннотация расширяет JPA @NamedNativeQuery с особенностями Hibernate.

@NamedQueries — аннотация используется для группирования нескольких аннотаций @NamedQuery.

@NamedQuery — аннотация расширяет JPA @NamedQuery с особенностями Hibernate.

@Nationalized — аннотация используется, чтобы указать, что текущий аннотированный атрибут является символьным типом (например, String, Character, Clob), который хранится в национализированном типе столбцов (NVARCHAR, NCHAR, NCLOB).

@NaturalId — аннотация используется, чтобы указать, что текущий аннотированный атрибут является частью естественного идентификатора объекта.

@NaturalIdCache — аннотация используется для указания того, что значения естественного id, связанные с аннотированным объектом, должны храниться в кэше второго уровня.

@NotFound — аннотация используется для указания стратегии NotFoundAction для того, когда элемент не найден в данной ассоциации. NotFoundAction определяет с двумя возможностями: 
EXCEPTION - исключение генерируется, когда элемент не найден (по умолчанию и рекомендуется). 
IGNORE - игнорировать элемент, если он не найден в базе данных.

@OnDelete — аннотация используется для указания стратегии удаления, используемой текущей аннотированной коллекцией, массивом или присоединенными подклассами. Эта аннотация используется инструментом генерации автоматизированной схемы для генерирования соответствующей директивы каскада FOREIGN KEY DDL. Две возможные стратегии определяются перечислением OnDeleteAction: 
CASCADE - использовать каскадные возможности базы данных FOREIGN KEY. 
NO_ACTION - не предпринимать никаких действий.

@OptimisticLock — аннотация используется, чтобы указать, будет ли текущий аннотированный атрибут запускать приращение версии объекта при изменении.

@OptimisticLocking — аннотация используется для указания текущей аннотированной оптимизированной стратегии блокировки сущности. Четыре возможные стратегии определяются перечислением OptimisticLockType: 
NONE - неявный оптимистический механизм блокировки отключен. 
VERSION - Неявный оптимистический механизм блокировки использует выделенный столбец версии. 
ALL - Неявный оптимистический механизм блокировки использует все атрибуты как часть расширенного предложения WHERE для операторов UPDATE и DELETE SQL. 
DIRTY - Неявный оптимистический механизм блокировки использует грязные атрибуты (атрибуты, которые были изменены) как часть расширенного предложения WHERE для операторов UPDATE и DELETE SQL.

@OrderBy — аннотация используется для указания директивы упорядочения SQL для сортировки текущей аннотированной коллекции. Он отличается от аннотации JPA @OrderBy, поскольку аннотация JPA ожидает фрагмент упорядочивания JPQL, а не директиву SQL.

@ParamDef — аннотация используется в сочетании с @FilterDef, так что фильтр Hibernate можно настроить с помощью значений параметров, предоставляемых во время выполнения.

@Parameter — аннотация является общим параметром (в основном комбинация ключ / значение), используемым для параметризации других аннотаций, таких как @CollectionType, @GenericGenerator и @Type, @TypeDef.

@Parent — аннотация используется, чтобы указать, что текущий аннотированный вложенный атрибут ссылается на владеющий объект.

@Persister — аннотация используется для указания настраиваемого объекта или коллекции persister. Для сущностей пользовательский персист должен реализовать интерфейс EntityPersister. Для коллекций пользовательский пульт должен реализовывать интерфейс CollectionPersister.

@Polymorphism — аннотация используется для определения PolymorphismType Hibernate применяется к иерархиям сущностей. Возможны две опции PolymorphismType: EXPLICIT - текущая аннотированная сущность извлекается только при явном запросе. IMPLICIT - текущая аннотированная сущность извлекается, если какой-либо ее сущностный объект извлекается. Это опция по умолчанию.

@Proxy — аннотация используется для указания настраиваемой реализации прокси для текущего аннотированного объекта.

@RowId — аннотация используется для указания столбца базы данных, который используется как псевдоколонка ROWID. Например, Oracle определяет псевдоколонку ROWID, которая предоставляет адрес каждой строки таблицы. Согласно документации Oracle, ROWID - это самый быстрый способ доступа к одной строке из таблицы.

@SelectBeforeUpdate — аннотация используется, чтобы указать, что текущее аннотированное состояние сущности будет выбрано из базы данных при определении, выполнять ли обновление, когда отсоединенный объект присоединен.

@SortComparator — аннотация используется для указания компаратора для сортировки Set / Map в памяти.

@SortNatural — аннотация используется, чтобы указать, что Set / Map должен быть отсортирован с использованием естественной сортировки.

@Source — аннотация используется в сочетании с атрибутом объекта timestamp @Version, указывающим SourceType значения метки времени. SourceType предлагает два варианта: DB - получить временную метку из базы данных. VM - получить временную метку из текущей JVM.

@SQLDelete — аннотация используется для указания пользовательского оператора SQL DELETE для текущего аннотированного объекта или коллекции.

@SQLDeleteAll — аннотация используется для указания пользовательского оператора SQL DELETE при удалении всех элементов текущей аннотированной коллекции.

@SqlFragmentAlias — аннотация используется для указания псевдонима для Hibernate @Filter. Псевдоним (например, myAlias) можно затем использовать в предложении условия @Filter, используя алиас {alias} (например, {myAlias}).

@SQLInsert — аннотация используется для указания пользовательского оператора SQL INSERT для текущего аннотированного объекта или коллекции.

@SQLUpdate — аннотация используется для указания пользовательской инструкции SQL UPDATE для текущего аннотированного объекта или коллекции.

@Subselect — аннотация используется для указания неизменяемого и доступного только для чтения объекта с использованием пользовательского оператора SQL SELECT.

@Synchronize — аннотация обычно используется совместно с аннотацией @Subselect для указания списка таблиц базы данных, используемых в SQL-запросе @Subselect. С помощью этой информации Hibernate должным образом инициирует флеш-сущность всякий раз, когда должен выполняться запрос, предназначенный для объекта @Subselect, в то время как контекст Persistence запланировал некоторые действия insert / update / delete для таблиц базы данных, используемых в SQL-запросе @Subselect. Поэтому аннотация @Synchronize предотвращает возврат производной сущности устаревших данных при выполнении запросов сущностей против @ Subselect.

@Table — аннотация используется для указания дополнительной информации в аннотациях JPA @Table, например, пользовательские инструкции INSERT, UPDATE или DELETE или определенный FetchMode.

@Tables — аннотация используется для объединения нескольких аннотаций @Table.

@Target — аннотация используется для указания явной целевой реализации, когда текущая аннотированная ассоциация использует тип интерфейса.

@Tuplizer — аннотация используется для указания настраиваемого tuplizer для текущего аннотированного объекта или встраиваемого объекта. Для сущностей тапилизатор должен реализовывать интерфейс EntityTuplizer. Для встраиваемых устройств тапилизатор должен реализовывать интерфейс ComponentTuplizer.

@Tuplizers — аннотация используется для группирования нескольких аннотаций @Tuplizer.

@Type — аннотация используется для указания Hibernate @Type, используемого текущим аннотированным основным атрибутом.

@TypeDef — аннотация используется для определения @Type, которое впоследствии может быть повторно использовано для нескольких базовых сопоставлений атрибутов.

@TypeDefs — аннотация используется для группировки нескольких аннотаций @TypeDef.

@UpdateTimestamp — аннотация используется, чтобы указать, что текущий атрибут аннотированной отметки времени должен обновляться с текущей меткой времени JVM всякий раз, когда модифицируется сущность. Тип данных: Java.util.Date, Java.util.Calendar, Java.sql.Date, Java.sql.Time, Java.sql.Timestamp.

@Where — аннотация используется для указания настраиваемого предложения SQL WHERE, используемого при выборке объекта или коллекции.

@WhereJoinTable — аннотация используется для указания пользовательского предложения SQL WHERE, при извлечении данных JOIN соединенных таблиц базы данных.

## Кеширование в Hibernate?
__Кеш 1-го уровня__ — кеш первого уровня всегда привязан к объекту сессии. Hibernate всегда по умолчанию использует этот кеш и его нельзя отключить. При использовании методов save(), update(), saveOrUpdate(), load(), get(), list(), iterate(), scroll() всегда будет задействован кеш первого уровня.

Интересно поведение кэша первого уровня при использовании ленивой загрузки. При загрузке объекта методом load() или объекта с лениво загружаемыми полями, лениво загружаемые данные в кэш не попадут. При обращении к данным будет выполнен запрос в базу и данные будут загружены и в объект и в кэш. А вот следующая попытка лениво загрузить объект приведёт к тому, что объект сразу вернут из кэша и уже полностью загруженным.

__Кеш 2-го уровня__ — кеш второго уровня привязан к объекту-фабрике сессий (Session Factory object). Что как бы подразумевает, что видимость этого кеша гораздо шире кеша первого уровня. Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня. По умолчанию кеш второго уровня отключен. Для включения необходимо добавить следующие строки в Вашем конфигурационном файле JPA (persistence.xml):

`<property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletonEhCacheProvider"/>`

`//или  в более старых версиях`

`//<property name="hibernate.cache.provider_class" value="org.hibernate.cache.EhCacheProvider"/>`

`<property name="hibernate.cache.use_second_level_cache" value="true"/>`

На самом деле, хибернейт сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации нашего ORM фреймворка. Из популярных реализаций можна выделить следующие: EHCache, OSCache, SwarmCache.

@Cacheable это аннотация JPA и позволяет объекту быть закэшированным. Hibernate поддерживает эту аннотацию в том же ключе.
@Cache это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. Аннотации @Cacheable  достаточно, чтобы объект начал кэшироваться с настройками по умолчанию. При этом @Cache использованная без @Cacheable не разрешит кэширование объекта.

@Cache  принимает три параметра:
+ include, имеющий по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение, non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.
+ region позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные кэши или разные части кэша, имеющие разные настройки на уровне реализации кэша. Например, я мог бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные во второй.
+ usage задаёт стратегию одновременного доступа к объектам.

Помимо всего этого, вероятней всего, Вам также понадобится отдельно настроить и саму реализацию кеша. В случае с EHCache это нужно сделать в файле ehcache.xml. Ну и в завершение еще нужно указать самому хибернейту, что именно кешировать. К счастью, это очень легко можно сделать с помощью аннотаций, например так: @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)

Еще одна важная деталь про кеш второго уровня про которую стоило бы упомянуть — хибернейт не хранит сами объекты Ваших классов. Он хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно можно представить себе это так:

`1 -> { "Pupkin", 1, null , {1,2,5} }`

При этом зависимости Вашего класса по умолчанию также не кешируются. Они будут подгружаться из БД, если их отдельно ен закешировать.

Для работы с кэшем второго уровня (second level cache) в JPA описан Cache интерфейс, содержащий большое количество методов по управлению кэшем второго уровня (second level cache), если он поддерживается провайдером JPA, конечно. Объект данного интерфейса можно получить с помощью метода getCache у EntityManagerFactory.

__Кеш запросов__  — Кеш запросов похож на кеш второго уровня. Но в отличии от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня. Он тоже по умолчанию отключен. Для включения нужно добавить следующую строку в конфигурационный файл:

`<property name="hibernate.cache.use_query_cache" value="true"/>`


## Стратегии кеширования? 
Стратегии кеширования определяют поведения кеша в определенных ситуациях. Выделяют четыре группы:
+ Read-only — объекты кэшируются только для чтения и изменение удаляет их из кэша.
+ Read-write — полноценный доступ к одной конкретной записи и разделение её состояния между транзакциями. Однако суммарное состояние нескольких объектов в разных транзакциях может отличаться.
+ Nonstrict-read-write — аналогичен read-write, но изменения объектов могут запаздывать и транзакции могут видеть старые версии объектов. Рекомендуется использовать в случаях, когда одновременное обновление объектов маловероятно и не может привести к проблемам.
+ Transactional — полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, как если бы только они с ним работали последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.

## Что такое Mapped Superclass?
Mapped Superclass это класс от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или соответственно описан в xml файле.

## Какие три типа стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?
В JPA описаны три стратегии наследования мапинга (Inheritance Mapping Strategies), то есть как JPA будет работать с классами-наследниками Entity:

1) одна таблица на всю иерархию наследования (a single table per class hierarchy) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog».Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно.

2) объединяющая стратегия (joined subclass strategy) — в этой стратегии каждый класс enity сохраняет данные в свою таблицу, но только уникальные колонки (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.

3) одна таблица для каждого класса (table per concrete class strategy) — тут все просто каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.

## Стратегии загрузки объектов в Hibernate? 
__Join fetching:__ hibernate получает ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN

__Select fetching:__ использует уточняющий SELECT чтобы получить ассоциированные объекты и коллекции. Если вы не установите lazy fetching определив lazy="false", уточняющий SELECT будет выполнен только когда вы запрашиваете доступ к ассоциированным объектам

__Subselect fetching:__ поведение такое же, как у предыдущего типа, за тем исключением, что будут загружены ассоциации для все других коллекций, "родительским" для которых является сущность, которую вы загрузили первым SELECT’ом.

__Batch fetching:__ оптимизированная стратегия вида select fetching. Получает группу сущностей или коллекций в одном SELECT’е

## Для чего нужна аннотация Basic?
Basic — указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.

## Для чего нужна аннотация Access?
Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).

## Для чего нужны callback методы в JPA? К каким сущностям применяются аннотации callback методов? Перечислите семь callback методов (или, что тоже самое, аннотаций callback методов)
Callback методы служат для вызова при определенных событиях Entity (то есть добавить обработку например удаления Entity методами JPA), могут быть добавлены к entity классу, к mapped superclass, или к callback listener классу, заданному аннотацией EntityListeners (см предыдущий вопрос). Существует семь callback методов (и аннотаций с теми же именами):
1) PrePersist
2) PostPersist
3) PreRemove
4) PostRemove
5) PreUpdate
6) PostUpdate
7) PostLoad

## Какие видов блокировок (lock) описаны в спецификации JPA?
В оптимистичных блокировках при коммите в базу данных производится сравнивание значения поля, помеченного как version, на момент получения данных и на данный момент. Если оно изменилось, то есть какая-то другая транзакция опередила нашу и успела изменить данные, то в таком случае наша транзакция выбрасывает ошибку, и необходимо заново запускать ее.

В пессимистичных же блокировка накладывается сразу же перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает.

LockModeType задает стратегию блокирования.

У JPA есть шесть видов блокировок, перечислим их в порядке увеличения надежности (от самого ненадежного и быстрого, до самого надежного и медленного):
1) NONE — без блокировки
2) OPTIMISTIC (или синоним READ, оставшийся от JPA 1) — оптимистическая блокировка,
3) OPTIMISTIC_FORCE_INCREMENT (или синоним WRITE, оставшийся от JPA 1) — оптимистическая блокировка с принудительным увеличением поля версионности,
4) PESSIMISTIC_READ — пессимистичная блокировка на чтение,
5) PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение),
6) PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности.

## Как можно изменить настройки fetch стратегии любых атрибутов Entity для отдельных запросов (query) или методов поиска (find), то если у Enity есть атрибут с fetchType = LAZY, но для конкретного запроса его требуется сделать EAGER или наоборот?
Для этого существует EntityGraph API, используется он так: с помощью аннотации NamedEntityGraph для Entity, создаются именованные EntityGraph объекты, которые содержат список атрибутов у которых нужно поменять fetchType на EAGER, а потом данное имя указывается в hits запросов или метода find. В результате fetchType атрибутов Entity меняется, но только для этого запроса. Существует две стандартных property для указания EntityGraph в hit:
1) javax.persistence.fetchgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные на LAZY
2) javax.persistence.loadgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные сохраняют свой fetchType (то есть если у атрибута, не указанного в EntityGraph, fetchType был EAGER, то он и останется EAGER)С помощью NamedSubgraph можно также изменить fetchType вложенных объектов Entity.

## Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?
В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но так же объекты всех его классов-потомков, независимо от стратегии наследования (например, запрос select * from Animal, вернет не только объекты Animal, но и объекты классов Cat и Dog, которые унаследованы от Animal). Чтобы исключить такое поведение используется функция TYPE в where условии (например select * from Animal a where TYPE(a) IN (Animal, Cat) уже не вернет объекты класса Dog).

## В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA
1) Конструктор без аргументов в Hibernate не обязан быть public или protected, рекомендуется чтобы он был хотя бы package видимости, однако это только рекомендация, если настройки безопасности Java позволяют доступ к приватным полям, то он может быть приватным.

2) JPA категорически требует не использовать final классы, Hibernate лишь рекомендует не использовать такие классы чтобы он мог создавать прокси для ленивой загрузки, однако позволяет либо выключить прокси Proxy(lazy=false), либо использовать в качестве прокси интерфейс, содержащий все методы маппинга для данного класса (аннотацией Proxy(proxyClass=интерфейс.class) )

## Каскадирование
При наличии зависимостей (связей) между сущностями необходимо определить влияние различных операций одной сущности на связанные. Это можно реализовать с помощью аннотации каскадных связей @Cascade.

Помните, что имеются некоторые различия между enum CascadeType в Hibernate и в JPA. Поэтому обращайте внимание на импортируемый пакет при использовании аннотации и константы типа. Наиболее часто используемые CascadeType перечисления описаны ниже :
+ None : без каскадирования, т.е. никакая операция для родителя не будет иметь эффекта для ребенка;
+ ALL : все операции родителя будут отражены на ребенке (save, delete, update, evict, lock, replicate, merge, persist);
+ SAVE_UPDATE : операции save и update, доступно только для hibernate;
+ DELETE : в Hibernate передается действие native DELETE;
+ DETATCH, MERGE, PERSIST, REFRESH, REMOVE – для простых операций;
+ LOCK : передает в Hibernate native LOCK действие;
+ REPLICATE : передает в Hibernate native REPLICATE действие.

## Как определить владельца связи?
Для того, чтобы объявить сторону, которая не несет ответственности за отношения, используется атрибут mappedBy. Он ссылается на имя свойства связи на стороне владельца.

## FetchType стратегии по-умолчанию?
Исторически Hibernate по умолчанию использует режим EAGER загрузки в отношении ManyToOne и OneToOne, а во всех остальных случаях — LAZY. Рекомендуется использовать LAZY во всех случаях. Указать в запросе делать join вместо нескольких select-ов всегда возможно, а обратно — отключить EAGER для определённых случаев — нет.

## Data и Enum значения в БД?
+ @Temporal(value=TemporalType.DATE) для Data до Java 8 версии. После 8 версии дополнительных аннотаций не требуется.

+ Для Enum нужно указать аннотацию @Enumerated, которая принимает параметр типа EnumType:
1. EnumType.STRING – это значит, что в базе будет хранится имя этого enum. То есть если мы зададим role = RoleEnum.ADMIN, то в БД в поле role будет хранится значение ADMIN.
2. EnumType.ORDINAL – это значит, что в базе будет хранится ID этого enum. ID – это место расположение в списке перечисления начиная с 0. Например если значение enum равно ADMIN, то в базе будет хранится число 2, а если будет ANONYMOUS, то в базе будет хранится 0.

## PersistenceContext
Экземпляр EntityManager связан с persistence context. Контекст сохранения-это кэш первого уровня, в котором все сущности извлекаются из базы данных или сохраняются в ней. Он находится между нашим приложением и постоянным хранилищем. Набор экземпляров сущности, в котором для любого персистентного идентификатора сущности существует уникальный экземпляр сущности. В persistence context управляются экземпляры сущностей и их жизненный цикл. API EntityManager используется для создания и удаления постоянных экземпляров сущностей, поиска сущностей по их первичному ключу и выполнения запросов к сущностям.

## Entity graph
EntityGraph (граф сущностей) - механизм динамического изменения fetchType для каждого запроса. Используя аннотации можно описать то, что будем выбирать из базы. Граф применяется на уровне SQL запроса, таким образом “лишние” данные не выбираются в Java приложение. Но есть одна небольшая проблема: нельзя сказать, какие атрибуты были выбраны, а какие — нет. Для проверки есть API, это делается при помощи класса PersistenceUtil.

## Пробелма n+1 select и как ее решить?
Есть User и которого есть коллекция машин Cars. Если мы хотим получить список из 10 юзеров, то в бд полетит 11 запросов. 1 запрос на получение самих юзеров и еще 10 запросов на получение списка их машин, отдельно для каждого User. Это приводит к серьёзным проблемам с производительностью.

__JOIN FETCH__

Самое правильное решение - использовать JOIN FETCH и jpql на выборку сущности. Данное решение не поддерживает работу с нативными запросами, но работает любым видом OneToMany/ManyToOne связи.

__FetchMode.SUBSELECT__

Использовать FetchMode.SUBSELECT и ленивую инициализацию. В этом случае, будет произведено два запроса: первый сделает выборку основной сущности, второй запрос отправится в базу после того, как мы обратимся к ленивому полю. Запрос будет один на получение всех связанных объектов. Данное решение не работает с нативными запросами и с полями, помеченными аннотацией @ManyToOne

__EntityGraph__
Использовать entityGraph. Не самое изящное решение для n+1 проблемы. Графы в основном нужны, когда требуется загрузить действительно большой детальный граф, т.е. когда нам нужно получить очень много связанной информации из базы, и такой большой запрос следует оптимизировать. Для n+1 не самое компактное решение, но тоже работает, однако такое решение не подойдет при использовании нативных запросов.

## JOIN FETCH vs Join
При запросе `JOIN emp.department dep` возвращается только сам запрощенный объект. При запросе `JOIN FETCH emp.department dep` возвращается объект и связанные с ним сущности, в одном запросе.

## OrderBy vs OrderColumn
Служат для установки порядка выдачи элементов коллекции. OrderBy упорядычевает только при выдачи результата. OrderColumn упорядычевает на постоянной основе, используя выделенный столбец данных.

## Как создать составной ключ
+ Первый метод использования составного ключа включает класс ключа целиком в класс сущности: @EmbeddedId указывает на поле составного первичного ключа, а @Embeddable объявляет класс составным ключом.
+ Второй вариант использования оставляет поля первичного ключа непосредственно в классе сущности, а класс составного ключа служит лишь для поддержки: @IdClass(Passport.PassportKey.class)

## GeneratedValue
Автоматически генерирует значение первичного ключа. Используется 4 стратегии (strategy = GenerationType.IDENTITY), Если мы не указываем значение явно, типом генерации по умолчанию является AUTO.
+ AUTO - значения определяется на основе типа атрибута первичного ключа, 
+ IDENTITY - тип генерации основан на IdentityGenerator , который ожидает значения, сгенерированные столбцом identity в базе данных, то есть они автоматически увеличиваются., 
+ SEQUENCE - генератор использует последовательности, если они поддерживаются нашей базой данных, и переключается на генерацию таблиц, если они не поддерживаются. Чтобы настроить имя последовательности, мы можем использовать аннотацию @ GenericGenerator со стратегией SequenceStyleGenerator,
+ TABLE - использует базовую таблицу базы данных, которая содержит сегменты значений генерации идентификатора.

Если мы не хотим использовать какие-либо из готовых стратегий, мы можем определить наш собственный генератор, реализуя интерфейс IdentifierGenerator .

## OrphanRemoval vs cascadeType.remove
+ OrphanRemoval объявляет, что дочерние экземпляры сущностей должны быть удалены, когда на них не ссылаются из родителя.

+ CascadeType.REMOVE: «Дочерняя» сущность удаляется только тогда, когда ее «Родитель» удаляется.

Если указан orphanRemoval = true, удаленный экземпляр адреса автоматически удаляется. Если указан только cascade = CascadeType.REMOVE автоматическое действие не выполняется, поскольку удаление отношения не является удалить операцию.

## ElementCollection
ElementCollection - стандартная аннотация JPA, означает, что коллекция не является совокупностью объектов, а представляет собой набор простых типов (строки и т.д.) или набор встраиваемых элементов (класс, аннотированный с помощью @Embeddable).

Это также означает, что элементы полностью принадлежат содержащим объектам: они изменяются, когда объект изменяется, удаляется при удалении объекта и т.д. Они не могут иметь свой собственный жизненный цикл.


# Источники
+ [Википедия - JDBC](https://ru.wikipedia.org/wiki/Java_Database_Connectivity)
+ [IBM developerWorks®](http://www.ibm.com/developerworks/ru/library/dm-1209storedprocedures/)
+ [Документация к пакету java.sql](https://docs.oracle.com/javase/7/docs/api/java/sql/package-summary.html)
+ [Википедия - Уровень изолированности транзакции](https://ru.wikipedia.org/wiki/Уровень_изолированности_транзакций)

[Вопросы для собеседования](README.md)
