[Вопросы для собеседования](README.md)

# JDBC
+ [Что такое JDBC?](#Что-такое-jdbc)
+ [Что такое JPA?](#Что-такое-jpa)
+ [Различия между JPA, JDBC и Hibernate?](#Различия-между-jpa-jdbc-и-hibernate)
+ [В чем заключаются преимущества использования JDBC?](#В-чем-заключаются-преимущества-использования-jdbc)
+ [Что из себя представляет JDBC URL?](#Что-из-себя-представляет-jdbc-url)
+ [Из каких частей стоит JDBC?](#Из-каких-частей-стоит-jdbc)
+ [Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?](#Перечислите-основные-классы-и-интерфейсы-jdbc)
+ [Опишите основные этапы работы с базой данных с использованием JDBC.](#Опишите-основные-этапы-работы-с-базой-данных-при-использовании-jdbc)
+ [Как зарегистрировать драйвер JDBC?](#Как-зарегистрировать-драйвер-jdbc)
+ [Как установить соединение с базой данных?](#Как-установить-соединение-с-базой-данных)
+ [Какие уровни изоляции транзакций поддерживаются в JDBC?](#Какие-уровни-изоляции-транзакций-поддерживаются-в-jdbc)
+ [При помощи чего формируются запросы к базе данных?](#При-помощи-чего-формируются-запросы-к-базе-данных)
+ [Чем отличается Statement от PreparedStatement?](#Чем-отличается-statement-от-preparedstatement)
+ [Как осуществляется запрос к базе данных и обработка результатов?](#Как-осуществляется-запрос-к-базе-данных-и-обработка-результатов)
+ [Как вызвать хранимую процедуру?](#Как-вызвать-хранимую-процедуру)
+ [Как закрыть соединение с базой данных?](#Как-закрыть-соединение-с-базой-данных)
+ [Что такое Entity?](#Что-такое-entity)
+ [Как наследуется Entity?](#Как-наследуется-entity)

## Что такое _ORM_?
__ORM (Object-relational mapping)__ — технология программирования, которая позволяет преобразовывать несовместимые типы моделей в ООП, в частности, между хранилищем данных и объектами программирования. ORM используется для упрощения процесса сохранения объектов в реляционную базу данных и их извлечения, при этом ORM сама заботится о преобразовании данных между двумя несовместимыми состояниями.

[к оглавлению](#jdbc)

## Что такое _JDBC_?
__JDBC, Java DataBase Connectivity (соединение с базами данных на Java)__ — промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета `java.sql`, входящего в состав Java SE.

JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

[к оглавлению](#jdbc)

## Что такое _JPA_?
__JPA (Java Persistence API)__ это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако есть существует много реализаций данной спецификации от разных компаний.

[к оглавлению](#jdbc)

## Различия _JPA_ _JDBC_ и __Hibernate__?
JDBC является гораздо более низкой (и более старой) спецификацией, чем JPA. JDBC - это API-интерфейс для взаимодействия с базой данных с использованием чистого SQL - отправки запросов и получения результатов. Он не имеет понятия об объектах или иерархиях. При использовании JDBC вам необходимо преобразовать набор результатов в объекты Java. 

А в JPA (который использует JDBC снизу) вы также указываете эти детали метаданных базы данных, но с использованием аннотаций Java. Таким образом, JPA создает запросы на обновление для вас и управляет объектами, которые вы искали или создали / обновили (это также делает больше).

Hibernate одна из самых популярных открытых реализаций последней версии спецификации. То есть JPA только описывает правила и API, а Hibernate реализует эти описания.

[к оглавлению](#jdbc)

## Что такое JPQL и HQL?
+ JPQL — Java Persistence Query Language. Фактически это как SQL, только запросы делаются не к таблицам, а к классам. JPQL основан на HQL.
+ HQL — Hibernate Query Language. Аналог SQL, но работает с сохраняемыми объектами (Persistent Objects) и их полями (аттрибутами класса). Мы также имеем возможность испольщовать обычные SQL – запросы в Hibernate используя Native SQL

## В чем заключаются преимущества использования JDBC?
Преимуществами JDBC считают:

+ Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;
+ Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);
+ Не нужно дополнительно устанавливать клиентскую программу;
+ К любой базе данных можно подсоединиться через легко описываемый URL.

[к оглавлению](#jdbc)

## Что из себя представляет JDBC URL?
__JDBC URL__ состоит из:

+ `<protocol>:` (протокола) - всегда `jdbc:`.
+ `<subprotocol>:` (подпротокола) - это имя драйвера или имя механизма соединения с базой данных. Подпротокол может поддерживаться одним или несколькими драйверами. Лежащий на поверхности пример подпротокола - это "odbc", отведенный для URL, обозначающих имя источника данных ODBC. В случае необходимости использовать сервис имен (т.е. имя базы данных в JDBC URL не будет действительным именем базы данных), то подпротоколом может выступать сервис имен.
+ `<subname>` (подимени) - это идентификатор базы данных. Значение подимени может менятся в зависимости от подпротокола, и может также иметь под-подимя с синтаксисом, определяемым разработчиком драйвера. Назначение подимени - это предоставление всей информации, необходимой для поиска базы данных. Например, если база данных находится в Интернет, то в состав подимени JDBC URL должен быть включен сетевой адрес, подчиняющийся следующим соглашениям: `//<hostname>:<port>/<subsubname`.

Пример JDBC URL для подключения к MySQL базе данных «Test» расположенной по адресу localhost и ожидающей соединений по порту 3306: `jdbc:mysql://localhost:3306/Test`

[к оглавлению](#jdbc)

## Из каких частей стоит JDBC?
JDBC состоит из двух частей:

+ __JDBC API__, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и методы объявлены в двух пакетах - `java.sql` и `javax.sql`;
+ __JDBC-драйвер__, компонент, специфичный для каждой базы данных. 

JDBC превращает вызовы уровня API в «родные» команды того или иного сервера баз данных.

[к оглавлению](#jdbc)

## Перечислите основные классы и интерфейсы JDBC.
+ `java.sql.DriverManager` - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.

+ `javax.sql.DataSource` - решает те же задачи, что и _DriverManager_, но более удобным и универсальным образом. Существуют также `javax.sql.ConnectionPoolDataSource` и `javax.sq1.XADataSource` задача которых - обеспечение поддержки пула соединений.

+ `java.sql.Connection`  - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы `javax.sql.PooledConnection` и `javax.sql.XAConnection`.

+ `java.sql.Statement` , `java.sql.PreparedStatement` и `java.sql.CallableStatement`  - эти интерфейсы позволяют отправить запрос к источнику данных.

+ `java.sql.ResultSet`  - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.

+ `java.sql.ResultSetMetaData`  - позволяет получить информацию о структуре набора данных.

+ `java.sql.DatabaseMetaData` - позволяет получить информацию о структуре источника данных.

[к оглавлению](#jdbc)

## Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?

| JDBC Type | Java Object Type |
|---------------:|---------------------------|
| __CHAR__ | `String` |
| __VARCHAR__ | `String` |
| __LONGVARCHAR__ | `String` |
| __NUMERIC__ | `java.math.BigDecimal` |
| __DECIMAL__ | `java.math.BigDecimal` |
| __BIT__ | `Boolean` |
| __TINYINT__ | `Integer` |
| __SMALLINT__ | `Integer` |
| __INTEGER__ | `Integer` |
| __BIGINT__ | `Long` |
| __REAL__ | `Float` |
| __FLOAT__ | `Double` |
| __DOUBLE__ | `Double` |
| __BINARY__ | `byte[]` |
| __VARBINARY__ | `byte[]` |
| __LONGVARBINARY__ | `byte[]` |
| __DATE__ | `java.sql.Date` |
| __TIME__ | `java.sql.Time` |
| __TIMESTAMP__ | `java.sql.Timestamp` |
| __CLOB__ | `Clob` |
| __BLOB__ | `Blob` |
| __ARRAY__ | `Array` |
| __STRUCT__ | `Struct`|
| __REF__ | `Ref` |
| __DISTINCT__ | сопоставление базового типа |
| __JAVA_OBJECT__ | базовый класс Java |

[к оглавлению](#jdbc)

## Опишите основные этапы работы с базой данных при использовании JDBC.
+ Регистрация драйверов;
+ Установление соединения с базой данных;
+ Создание запроса(ов) к базе данных;
+ Выполнение запроса(ов) к базе данных;
+ Обработка результата(ов);
+ Закрытие соединения с базой данных.

[к оглавлению](#jdbc)

## Как зарегистрировать драйвер JDBC?
Регистрацию драйвера можно осуществить несколькими способами:

+ `java.sql.DriverManager.registerDriver(%объект класса драйвера%)`.  

+ `Class.forName(«полное имя класса драйвера»).newInstance()`.

+ `Class.forName(«полное имя класса драйвера»)`;

[к оглавлению](#jdbc)

## Как установить соединение с базой данных?
Для установки соединения с базой данных используется статический вызов `java.sql.DriverManager.getConnection(...)` .


В качестве параметра может передаваться:

+ URL базы данных
```java
static Connection getConnection(String url)
```

+ URL базы данных и набор свойств для инициализации
```java
static Connection getConnection(String url, Properties info)
```

+ URL базы данных, имя пользователя и пароль
```java
static Connection getConnection(String url, String user, String password)
```
 
В результате вызова будет установлено соединение с базой данных и создан объект класса `java.sql.Connection` - своеобразная «сессия», внутри контекста которой и будет происходить дальнейшая работа с базой данных.

[к оглавлению](#jdbc)

## Какие уровни изоляции транзакций поддерживаются в JDBC?
__Уровень изолированности транзакций__ — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:

+ _«грязное» чтение (dirty read)_ — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);

+ _неповторяющееся чтение (non-repeatable read)_ — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;

+ _фантомное чтение (phantom reads)_ — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

Уровни изоляции транзакций определены в виде констант интерфейса `java.sql.Connection`:

+ `TRANSACTION_NONE` – драйвер не поддерживает транзакции;

+ `TRANSACTION_READ_UNCOMMITTED` – позволяет транзакциям видеть несохраненные изменения данных: разрешает грязное, непроверяющееся и фантомное чтения;

+ `TRANSACTION_READ_COMMITTED` – любое изменение, сделанное в транзакции, не видно вне неё, пока она не сохранена: предотвращает грязное чтение, но разрешает непроверяющееся и фантомное;

+ `TRANSACTION_REPEATABLE_READ` – запрещает грязное и непроверяющееся, фантомное чтение разрешено;

+ `TRANSACTION_SERIALIZABLE` – грязное, непроверяющееся и фантомное чтения запрещены.

> __NB!__ Сервер базы данных может не поддерживать все уровни изоляции. Интерфейс `java.sql.DatabaseMetaData` предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.

Уровень изоляции транзакции используемый СУБД можно задать с помощью метода `setTransactionIsolation()` объекта `java.sql.Connection`. Получить информацию о применяемом уровне изоляции поможет метод `getTransactionIsolation()`.

[к оглавлению](#jdbc)

## При помощи чего формируются запросы к базе данных?

Для выполнения запросов к базе данных в Java используются три интерфейса:

+ `java.sql.Statement` - для операторов SQL без параметров;
+ `java.sql.PreparedStatement` - для операторов SQL с параметрами и часто выполняемых операторов;
+ `java.sql.CallableStatement` -  для исполнения хранимых в базе процедур.

Объекты-носители интерфейсов создаются при помощи методов объекта `java.sql.Connection`:

+ `java.sql.createStatement()` возвращает объект _Statement_;
+ `java.sql.prepareStatement()` возвращает объект _PreparedStatement_;
+ `java.sql.prepareCall()` возвращает объект _CallableStatement_;

[к оглавлению](#jdbc)

## Чем отличается Statement от PreparedStatement?
+ __Statement__: используется для простых случаев запроса без параметров.
+ __PreparedStatement__: предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.

Перед выполнением СУБД разбирает каждый запрос, оптимизирует его и создает «план» (query plan) его выполнения. Если один и тот же запрос выполняется несколько раз, то СУБД в состоянии кэшировать план его выполнения и не производить этапов разборки и оптимизации повторно. Благодаря этому запрос выполняется быстрее.

Суммируя: _PreparedStatement_ выгодно отличается от _Statement_ тем, что при повторном использовании с одним или несколькими наборами параметров позволяет получить преимущества заранее прекомпилированного и кэшированного запроса, помогая при этом избежать SQL Injection.

[к оглавлению](#jdbc)

## Как осуществляется запрос к базе данных и обработка результатов?
Выполнение запросов осуществляется при помощи вызова методов объекта, реализующего интерфейс `java.sql.Statement`:

+ __`executeQuery()`__ -  для запросов, результатом которых является один набор значений, например запросов `SELECT`. Результатом выполнения является объект класса `java.sql.ResultSet`;
 
+ __`executeUpdate()`__ - для выполнения операторов `INSERT`, `UPDATE` или `DELETE`, а также для операторов _DDL (Data Definition Language)_. Метод возвращает целое число, показывающее, сколько записей было модифицировано;

+ __`execute()`__ – исполняет SQL-команды, которые могут возвращать различные результаты. Например, может использоваться для операции `CREATE TABLE`. Возвращает `true`, если первый результат содержит _ResultSet_ и `false`, если первый результат - это количество модифицированных записей или результат отсутствует. Чтобы получить первый результат необходимо вызвать метод `getResultSet()` или `getUpdateCount()`. Остальные результаты доступны через вызов `getMoreResults()`, который при необходимости может быть произведён многократно.

Объект с интерфейсом `java.sql.ResultSet` хранит в себе результат запроса к базе данных - некий набор данных, внутри которого есть курсор, указывающий на один из элементов набора данных - текущую запись.

Используя курсор можно перемещаться по набору данных при помощи метода `next()`.

> __NB!__ Сразу после получения набора данных его курсор находится перед первой записью и чтобы сделать её текущей необходимо вызвать метод `next()`.

Содержание полей текущей записи доступно через вызовы методов `getInt()`, `getFloat()`, `getString()`, `getDate()` и им подобных.

[к оглавлению](#jdbc)

## Как вызвать хранимую процедуру?
__Хранимые процедуры__ – это именованный набор операторов SQL хранящийся на сервере. Такую процедуру можно вызвать из Java-класса с помощью вызова методов объекта реализующего интерфейс `java.sql.Statement`.

Выбор объекта зависит от характеристик хранимой процедуры:

+ без параметров → `Statement`
+ с входными параметрами → `PreparedStatement`
+ с входными и выходными параметрами → `CallableStatement`

> Если неизвестно, как была определена хранимая процедура, для получения информации о хранимой процедуре (например, имен и типов параметров) можно использовать методы `java.sql.DatabaseMetaData` позволяющие получить информацию о структуре источника данных.

Пример вызова хранимой процедуры с входными и выходными параметрами:

```java
public vois runStoredProcedure(final Connection connection) throws Exception {
    // описываем хранимую процедуру
    String procedure = "{ call procedureExample(?, ?, ?) }";
    
    // подготавливаем запрос
    CallableStatement cs = connection.prepareCall(procedure);
    
    // устанавливаем входные параметры
    cs.setString(1, "abcd");
    cs.setBoolean(2, true);
    cs.setInt(3, 10);
    
    // описываем выходные параметры
    cs.registerOutParameter(1, java.sql.Types.VARCHAR);
    cs.registerOutParameter(2, java.sql.Types.INTEGER);
    
    // запускаем выполнение хранимой процедуры
    cs.execute();
    
    // получаем результаты
    String parameter1 = cs.getString(1);
    int parameter2 = cs.getInt(2);
    
    // заканчиваем работу с запросом
    cs.close();
}
```

[к оглавлению](#jdbc)

## Как закрыть соединение с базой данных?
Соединение с базой данной закрывается вызовом метода `close()` у соответствующего объекта `java.sql.Connection` или посредством использования механизма try-with-resources при создании такого объекта, появившегося в Java 7.

> __NB!__ Предварительно необходимо закрыть все запросы созданные этим соединением.

[к оглавлению](#jdbc)

## Что такое Entity?
Entity это легковесный хранимый объект бизнес логики (persistent domain object). Основная программная сущность это entity класс, который так же может использовать дополнительные классы, который могут использоваться как вспомогательные классы или для сохранения состояния еntity.

JPA указывает что она может работать как с свойствами классов (property), оформленные в стиле JavaBeans, либо с полями (field), то есть переменными класса (instance variables). Соответственно, при этом тип доступа будет либо property access или field access. Оба типа элементов Entity класса называются _атрибутами Entity класса_.

Допустимые типы атрибутов у Entity классов:
+ примитивные типы и их обертки Java,
+ строки,
+ любые сериализуемые типы Java (реализующие Serializable интерфейс),
+ enums;
+ entity types;
+ embeddable классы
+ и коллекции типов 1-6

Требования JPA к Entity классам:
1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами),
3) Entity класс должен быть классом верхнего уровня (top-level class),
4) Entity класс не может быть enum или интерфейсом,
5) Entity класс не может быть финальным классом (final class),
6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
9) Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,

[к оглавлению](#jdbc)

## Как наследуется Entity?
+ Может наследоваться и от других Entity классов, и от не Entity классов. 
+ Не Entity классы так же могут наследоваться от Entity. 
+ Может быть абстрактным, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.

[к оглавлению](#jdbc)
## Что такое POJO-класс?
Plain Old Java Object - простой Java-объект, не унаследованный от какого-то специфического объекта и не реализующий никаких служебных интерфейсов сверх тех, которые нужны для бизнес-модели.

[к оглавлению](#jdbc)

## Какие типы данных можно использовать в атрибутах, входящих в первичный ключ Entity класса (составной или простой), чтобы полученный первичный ключ мог использоваться для любой базы данных? А в случае автогенерируемого первичного ключа (generated primary keys)?
Допустимые типы атрибутов, входящих в первичный ключ:
1. примитивные типы и их обертки Java,
2. строки,
3. BigDecimal и BigInteger,
4. java.util.Date и java.sql.Date

В случае автогенерируемого первичного ключа (generated primary keys) допустимы только числовые типы.<br>
В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е. становится не переносимым (not portable).

[к оглавлению](#jdbc)

## Что такое встраиваемый (Embeddable) класс?
Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity, можно считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.

[к оглавлению](#jdbc)

## Может ли встраиваемый (Embeddable) класс содержать другой встраиваемый (Embeddable) класс?
Да, может.

[к оглавлению](#jdbc)

## Может ли встраиваемый (Embeddable) класс содержать связи (relationship) с другими Entity или коллекциями Entity? Если может, то существуют ли какие-то ограничение на такие связи (relationship)?
Может, но только в случае если такой класс не используется как первичный ключ или ключ map’ы.

[к оглавлению](#jdbc)

## Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity (см. вопрос 10),
2. Embeddable класс должен быть отмечен аннотацией Embeddable или описан в XML файле конфигурации JPA.

[к оглавлению](#jdbc)
## Основные классы и интерфейсы JPA
__EntityManagerFactory__ – фабричный класс EntityManager. Он создает и управляет несколькими экземплярами EntityManager. Создание EntityManagerFactory  довольно дорогая операция, поэтому обычно её создают один раз и на всё приложение.

Методы:
+ createEntityManager()
+ createEntityManager(Map map) - Create a new application-managed EntityManager with the specified Map of properties.
+ close() - Close the factory, releasing any resources that it holds.
+ getCache() - Access the cache that is associated with the entity manager factory (the "second level cache").
+ getCriteriaBuilder() - Return an instance of CriteriaBuilder for the creation of CriteriaQuery objects.
+ getMetamodel() - Return an instance of Metamodel interface for access to the metamodel of the persistence unit.
+ getPersistenceUnitUtil() - Return interface providing access to utility methods for the persistence unit.
+ getProperties() - Get the properties and associated values that are in effect for the entity manager factory.
+ isOpen() - Indicates whether the factory is open.

__EntityManager__ – интерфейс, вызывая методы которого можно управлять сущностями. В отличие от фабрики, достаточно легковесен и поэтому зачастую создаётся по месту использования и в больших количествах. Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.

__Методы операций над Entity:__
+ persist (добавление Entity под управление JPA)
+ merge (обновление)
+ remove (удаления)
+ refresh (обновление данных)
+ detach (удаление из управление JPA)
+ lock (блокирование Enity от изменений в других thread).
__Методы получение данных:__
+ find (поиск и получение Entity)
+ createQuery, createNamedQuery, createNativeQuery
+ contains
+ createNamedStoredProcedureQuery, createStoredProcedureQuery
__Получение других сущностей JPA:__ 
+ getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
__Работа с EntityGraph:__
+ createEntityGraph, getEntityGraph
__Общие операции над EntityManager или всеми Entities:__ 
+ close, isOpen, getProperties, setProperty, clear.

__Entity__ – это постоянные объекты, хранящиеся в виде записей в базе данных.

__EntityTransaction__ – интерфейс для работы с транзакциями. Он имеет непосредственное отношение к EntityManager. Для каждого EntityManager операции поддерживаются классом EntityTransaction.

Методы: 
+ begin() - Start a resource transaction.
+ commit() - Commit the current resource transaction, writing any unflushed changes to the database.
+ getRollbackOnly() - Determine whether the current resource transaction has been marked for rollback.
+ isActive() - Indicate whether a resource transaction is in progress.
+ rollback() - Roll back the current resource transaction.
+ setRollbackOnly() - Mark the current resource transaction so that the only possible outcome of the transaction is for the transaction to be rolled back.

__Persistence__ – Этот класс содержит статические методы для получения экземпляра EntityManagerFactory.

__Query__ – Этот интерфейс реализуется каждым поставщиком JPA для получения реляционных объектов, соответствующих критериям.

[к оглавлению](#jdbc)
## Что такое Метамодель?
Для получения метаданные JPA (сведения о Entity типах, Embeddable и Managed классах и т.п.) используется интерфейс Metamodel. Объект этого интерфейса можно получить методом getMetamodel у EntityManagerFactory или EntityManager.

[к оглавлению](#jdbc)
## Основные классы и интерфейсы Hibernate?
__SessionFactory__ – используется для получения объектов Session, которые используются для операций с базами данных. SessionFactory отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных. Неизменяемый потокобезопасный объект с компилированным маппингом для одной базы данных. Необходимо инициализировать SessionFactory всего один раз.

__Session__ – однопоточный короткоживущий объект, который предоставляет связь между объектами приложения и базой данных. Он оборачивает JDBC java.sql.Connection и работает как фабрика для org.hibernate.Transaction. Разработчик должен открывать сессию по необходимости и закрывать ее сразу после использования. Экземпляр Session является интерфейсом между кодом в java приложении и hibernate framework и предоставляет методы для операций CRUD. 

__Transaction__ – однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать несколько org.hibernate.Transaction в определенных случаях.

[к оглавлению](#jdbc)

## SessionFactory vs EntityManagerFactory и Session vs EntityManager?
Hibernate появился раньше JPA. К этому времени у HIBERNATE был большой наработанный функционал, а в для первой версии JPA удалось согласовать только часть этого объема функционала. Поэтому, разработчики HIBERNATE сознательно пошли на то, чтобы в HIBERNATE имелось два пути работы - старый путь - нативный HIBERNATE (через интерфейс Session) и новый путь JPA (через интерфейс EntityManager). 

Интерфейсы разные, методы как правило имеют одинаковые названия. Различия есть и в других элементах. При этом, функциональность нативного HIBERNATE значительно больше, чем у JPA. И вообще, реализация EntityManager является оберткой (wrap) реализации Session. Класс SessionImpl реализует интерфейс Session, а Session расширяет интерфейс EntityManager. 

Если Вы выбираете путь JPA, то всегда имеете возможность быстро перейти, на другие реализации JPA- EclipseLink, OpenJPA, DataNucleus (и узнаете насколько они совместимы).

[к оглавлению](#jdbc)

## Жизненный цикл Entity?
У Entity объекта существует четыре статуса жизненного цикла: 
+ new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных,
+ managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи,
+ detached — объект был создан, но не управляется (или больше не управляется) JPA,
+ removed — объект создан, управляется JPA, но будет удален после commit'a транзакции

## Влияние операций EntityManager на Entity объекты различный жизненных циклов?
__Persist__ <br>
1) Если статус Entity new, то он меняется на managed и объект будет сохранен в базу при commit'е транзакции или в результате flush операций,
2) Если статус уже managed, операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений,
3) Если статус removed, то он меняется на managed,
4) Если статус detached, будет выкинут exception сразу или на этапе commit'а транзакции,

__Remove__<br>
1) Если статус Entity new, операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed,
2) Если статус managed, то статус меняется на removed и запись объект в базе данных будет удалена при commit'е транзакции (так же произойдут операции remove для всех каскадно зависимых объектов),
3) Если статус removed, то операция игнорируется,
4) Если статус detached, будет выкинут exception сразу или на этапе commit'а транзакции,

__Merge__<br>
1) Если статус detached, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные,
1) Если статус Entity new, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта,
2) Если статус managed, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed,
3) Если статус removed, будет выкинут exception сразу или на этапе commit'а транзакции,

__Refresh__<br>
1) Если статус Entity managed, то в результате операции будут востановлены все изменения из базы данных данного Entity, так же произойдет refresh всех каскадно зависимых объектов,
2) Если статус new, removed или detached, будет выкинут exception,

__Detach__<br>
1) Если статус Entity managed или removed, то в результате операции статус Entity (и всех каскадно-зависимых объектов) станет detached.
2) Если статус new или detached, то операция игнорируется,

## Аннотации JPA
@Entity — Указывает, что данный бин (класс) является сущностью.

@Table — указывает на имя таблицы, которая будет отображаться в этой сущности.

@Column — указывает на имя колонки, которая отображается в свойство сущности.

@GeneratedValue — указывает, что данное свойство будет создаваться согласно указанной стратегии.

@Version — управление версией в записи сущности. При изменении записи увеличится на 1.

@OrderBy — указание сортировки. В примере множество кошек будет отсортировано по имени по возрастанию.

@Transient — указывает, что свойство не нужно записывать. Значения под этой аннотацией не записываются в базу данных (так же не участвуют в сериализации). static и final переменные экземпляра всегда transient.

@Lob — указание на большие объекты.

@PersistenceContext — указывает на зависимость EntityManager в контейнере

@Temporal — применяется к полям или свойствам с типом java.util.Date и java.util.Calendar. Например, если в БД время сохраняется как sql.Date, то чтобы использовать дату из java.util.Date указываем эту аннотацию.

@Embeddable и @Embedded («встроенный») — Определяет класс, экземпляры которого хранятся как неотъемлемая часть исходного объекта. Каждый из @Embedded экземпляров сопоставляется с таблицей базы данных сущности.

@OneToOne —  указывает на связь между таблицами «один к одному». Параметр orphanRemoval — позволяет удалять объекты сироты. При удалении родительского объекта удаляется и дочерний. (@OneToMany(mappedBy=»customer», orphanRemoval=»true»)) Параметр mappedBy — обратная сторона связи сущности. Поле под этим атрибутом не сохраняется как часть исходной сущности в базе данных, но будет доступна по запросу. (см. ниже @JoinColumn) Параметр cascade = CascadeType.ALL — означает, что операция, например, записи должна распространяться и на дочерние таблицы.

@PrimaryKeyJoinColumn — главный ключ для ассоциированной сущности с таким же ключом

@JoinColumn  — применяется когда внешний ключ находится в одной из сущностей. Может применяться с обеих сторон взаимосвязи. Но рекомендуется применять в сущности, которая является владельцем физической информации (обычно сторона @ManyToOne). ManyToOne (часто) является стороной-владельцем в двунаправленных связях и таким образом противоположная сторона использует @OneToMany(mappedBy=..).

@JoinTable — указывает на связь с таблицей

@ManyToOne — указывает на связь многие к одному.

@OneToMany — указывает на связь один ко многим. Применяется с другой стороны от сущности с @ManyToOne

@ManyToMany — связь многие ко многим.

@MapsId — связывает одну колонку с другой. Работает с @Id и @EmbeddedId.

@NamedQueries — внутри указывается список именованных запросов.

@NamedQuery — имя именованного запроса и сам запрос.

@SqlResultSetMapping — куда будет собран результат.

@EntityResult — указание сущности в которой будет сконструирован результат.

## Аннотации Hibernate
@Audited — Включает аудит сущности (отслеживание версий).
@NotAudited — указывает, что изменения этого свойства отслеживать не нужно. По умолчанию Hibernate пытается отслеживать изменения в ассоциациях.
@Type указывает на тип свойства


# Источники
+ [Википедия - JDBC](https://ru.wikipedia.org/wiki/Java_Database_Connectivity)
+ [IBM developerWorks®](http://www.ibm.com/developerworks/ru/library/dm-1209storedprocedures/)
+ [Документация к пакету java.sql](https://docs.oracle.com/javase/7/docs/api/java/sql/package-summary.html)
+ [Википедия - Уровень изолированности транзакции](https://ru.wikipedia.org/wiki/Уровень_изолированности_транзакций)

[Вопросы для собеседования](README.md)
